{"version":3,"sources":["../../src/utils/api-node-docs.ts"],"names":["resolvableExtensions","createPages","createPagesStatefully","sourceNodes","onCreateNode","unstable_shouldOnCreateNode","onCreatePage","setFieldsOnGraphQLNodeType","createSchemaCustomization","createResolvers","preprocessSource","onCreateBabelConfig","onCreateWebpackConfig","onPreInit","unstable_onPluginInit","onPreBootstrap","onPostBootstrap","onPreBuild","onPostBuild","onPreExtractQueries","onCreateDevServer","pluginOptionsSchema"],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACO,MAAMA,oBAAoB,GAAG,IAA7B;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEO,MAAMC,WAAW,GAAG,IAApB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,qBAAqB,GAAG,IAA9B;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,WAAW,GAAG,IAApB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,YAAY,GAAG,IAArB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,2BAA2B,GAAG,IAApC;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,YAAY,GAAG,IAArB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,0BAA0B,GAAG,IAAnC;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,yBAAyB,GAAG,IAAlC;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,eAAe,GAAG,IAAxB;AAEP;AACA;AACA;AACA;;;AACO,MAAMC,gBAAgB,GAAG,IAAzB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,mBAAmB,GAAG,IAA5B;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,qBAAqB,GAAG,IAA9B;AAEP;AACA;AACA;;;AACO,MAAMC,SAAS,GAAG,IAAlB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,qBAAqB,GAAG,IAA9B;AAEP;AACA;AACA;;;AACO,MAAMC,cAAc,GAAG,IAAvB;AAEP;AACA;AACA;;;AACO,MAAMC,eAAe,GAAG,IAAxB;AAEP;AACA;AACA;;;AACO,MAAMC,UAAU,GAAG,IAAnB;AAEP;AACA;AACA;AACA;;;AACO,MAAMC,WAAW,GAAG,IAApB;AAEP;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,mBAAmB,GAAG,IAA5B;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,iBAAiB,GAAG,IAA1B;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMC,mBAAmB,GAAG,IAA5B","sourcesContent":["/**\n * Lets plugins implementing support for other compile-to-js add to the list\n * of \"resolvable\" file extensions. Gatsby supports `.js` and `.jsx` by default.\n * @returns {Array<string>} array of extensions\n */\nexport const resolvableExtensions = true\n\n/**\n * Create pages dynamically. This extension point is called only after the initial\n * sourcing and transformation of nodes plus creation of the GraphQL schema are\n * complete so you can query your data in order to create pages.\n *\n * You can also fetch data from remote or local sources to create pages.\n *\n * See also [the documentation for the action `createPage`](/docs/actions/#createPage).\n *\n * @param {object} $0 See the [documentation for `Node API Helpers` for more details](/docs/node-api-helpers)\n * @param {Actions} $0.actions See the [list of documented actions](/docs/actions)\n * @param {function} $0.actions.createPage [Documentation for this action](/docs/actions/#createPage)\n * @param {function} $0.graphql: Query GraphQL API. See [examples here](/docs/creating-and-modifying-pages/#creating-pages-in-gatsby-nodejs)\n * @param {GatsbyReporter} $0.reporter Log issues. See [GatsbyReporter documentation](/docs/node-api-helpers/#GatsbyReporter) for more details\n * @returns {Promise<void>} No return value required, but the caller will `await` any promise that's returned\n *\n * @example\n * const path = require(`path`)\n *\n * exports.createPages = ({ graphql, actions }) => {\n *   const { createPage } = actions\n *   const blogPostTemplate = path.resolve(`src/templates/blog-post.js`)\n *   // Query for markdown nodes to use in creating pages.\n *   // You can query for whatever data you want to create pages for e.g.\n *   // products, portfolio items, landing pages, etc.\n *   // Variables can be added as the second function parameter\n *   return graphql(`\n *     query loadPagesQuery ($limit: Int!) {\n *       allMarkdownRemark(limit: $limit) {\n *         edges {\n *           node {\n *             frontmatter {\n *               slug\n *             }\n *           }\n *         }\n *       }\n *     }\n *   `, { limit: 1000 }).then(result => {\n *     if (result.errors) {\n *       throw result.errors\n *     }\n *\n *     // Create blog post pages.\n *     result.data.allMarkdownRemark.edges.forEach(edge => {\n *       createPage({\n *         // Path for this page â€” required\n *         path: `${edge.node.frontmatter.slug}`,\n *         component: blogPostTemplate,\n *         context: {\n *           // Add optional context data to be inserted\n *           // as props into the page component.\n *           //\n *           // The context data can also be used as\n *           // arguments to the page GraphQL query.\n *           //\n *           // The page \"path\" is always available as a GraphQL\n *           // argument.\n *         },\n *       })\n *     })\n *   })\n * }\n */\n\nexport const createPages = true\n\n/**\n * Like `createPages` but for plugins who want to manage creating and removing\n * pages themselves in response to changes in data *not* managed by Gatsby.\n * Plugins implementing `createPages` will get called regularly to recompute\n * page information as Gatsby's data changes but those implementing\n * `createPagesStatefully` will not.\n *\n * An example of a plugin that uses this extension point is the plugin\n * [gatsby-plugin-page-creator](https://github.com/gatsbyjs/gatsby/tree/master/packages/gatsby-plugin-page-creator)\n * which monitors the `src/pages` directory for the adding and removal of JS\n * pages. As its source of truth, files in the pages directory, is not known by\n * Gatsby, it needs to keep its own state about its world to know when to\n * add and remove pages.\n */\nexport const createPagesStatefully = true\n\n/**\n * Extension point to tell plugins to source nodes. This API is called during\n * the Gatsby bootstrap sequence. Source plugins use this hook to create nodes.\n * This API is called exactly once per plugin (and once for your site's\n * `gatsby-config.js` file). If you define this hook in `gatsby-node.js` it\n * will be called exactly once after all of your source plugins have finished\n * creating nodes.\n *\n * The [Creating a Source\n * Plugin](/docs/how-to/plugins-and-themes/creating-a-source-plugin/) tutorial\n * demonstrates a way a plugin or site might use this API.\n *\n * See also the documentation for [`createNode`](/docs/actions/#createNode).\n * @example\n * exports.sourceNodes = ({ actions, createNodeId, createContentDigest }) => {\n *   const { createNode } = actions\n *\n *   // Data can come from anywhere, but for now create it manually\n *   const myData = {\n *     key: 123,\n *     foo: `The foo field of my node`,\n *     bar: `Baz`\n *   }\n *\n *   const nodeContent = JSON.stringify(myData)\n *\n *   const nodeMeta = {\n *     id: createNodeId(`my-data-${myData.key}`),\n *     parent: null,\n *     children: [],\n *     internal: {\n *       type: `MyNodeType`,\n *       mediaType: `text/html`,\n *       content: nodeContent,\n *       contentDigest: createContentDigest(myData)\n *     }\n *   }\n *\n *   const node = Object.assign({}, myData, nodeMeta)\n *   createNode(node)\n * }\n */\nexport const sourceNodes = true\n\n/**\n * Called when a new node is created. Plugins wishing to extend or\n * transform nodes created by other plugins should implement this API.\n *\n * See also the documentation for [`createNode`](/docs/actions/#createNode)\n * and [`createNodeField`](/docs/actions/#createNodeField)\n *\n * The [Creating a Source\n * Plugin](/docs/how-to/plugins-and-themes/creating-a-source-plugin/) tutorial\n * demonstrates a way a plugin or site might use this API.\n *\n * @example\n * exports.onCreateNode = ({ node, actions }) => {\n *   const { createNode, createNodeField } = actions\n *   // Transform the new node here and create a new node or\n *   // create a new node field.\n * }\n */\nexport const onCreateNode = true\n\n/**\n * Called before scheduling a `onCreateNode` callback for a plugin. If it returns falsy\n * then Gatsby will not schedule the `onCreateNode` callback for this node for this plugin.\n * Note: this API does not receive the regular `api` that other callbacks get as first arg.\n *\n * @gatsbyVersion 2.24.80\n * @example\n * exports.unstable_shouldOnCreateNode = ({node}, pluginOptions) => node.internal.type === 'Image'\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const unstable_shouldOnCreateNode = true\n\n/**\n * Called when a new page is created. This extension API is useful\n * for programmatically manipulating pages created by other plugins e.g.\n * if you want paths without trailing slashes.\n *\n * There is a mechanism in Gatsby to prevent calling onCreatePage for pages\n * created by the same gatsby-node.js to avoid infinite loops/callback.\n *\n * See the guide [Creating and Modifying Pages](/docs/creating-and-modifying-pages/)\n * for more on this API.\n */\nexport const onCreatePage = true\n\n/**\n * Called during the creation of the GraphQL schema. Allows plugins\n * to add new fields to the types created from data nodes. It will be called\n * separately for each type.\n *\n * This function should return an object in the shape of\n * [GraphQLFieldConfigMap](https://graphql.org/graphql-js/type/#graphqlobjecttype)\n * which will be appended to fields inferred by Gatsby from data nodes.\n *\n * *Note:* Import GraphQL types from `gatsby/graphql` and don't add the `graphql`\n * package to your project/plugin dependencies to avoid `Schema must\n * contain unique named types but contains multiple types named` errors.\n * `gatsby/graphql` exports all builtin GraphQL types as well as the `GraphQLJSON`\n * type.\n *\n * Many transformer plugins use this to add fields that take arguments.\n *\n * * [`gatsby-transformer-remark`](/plugins/gatsby-transformer-remark/)\n * adds an \"excerpt\" field where the user when writing their query can specify\n * how many characters to prune the markdown source to.\n * * [`gatsby-transformer-sharp`](/plugins/gatsby-transformer-sharp/) exposes\n * many image transformation options as GraphQL fields.\n *\n * @param {object} $0\n * @param {object} $0.type Object containing `name` and `nodes`\n * @example\n * import { GraphQLString } from \"gatsby/graphql\"\n *\n * exports.setFieldsOnGraphQLNodeType = ({ type }) => {\n *   if (type.name === `File`) {\n *     return {\n *       newField: {\n *         type: GraphQLString,\n *         args: {\n *           myArgument: {\n *             type: GraphQLString,\n *           }\n *         },\n *         resolve: (source, fieldArgs) => {\n *           return `Id of this node is ${source.id}.\n *                   Field was called with argument: ${fieldArgs.myArgument}`\n *         }\n *       }\n *     }\n *   }\n *\n *   // by default return empty object\n *   return {}\n * }\n */\nexport const setFieldsOnGraphQLNodeType = true\n\n/**\n * Customize Gatsby's GraphQL schema by creating type definitions, field\n * extensions or adding third-party schemas.\n *\n * The [`createTypes`](/docs/actions/#createTypes),\n * [`createFieldExtension`](/docs/actions/#createFieldExtension) and\n * [`addThirdPartySchema`](/docs/actions/#addThirdPartySchema) actions\n * are only available in this API. For details on their usage please refer to\n * the actions documentation.\n *\n * This API runs immediately before schema generation. For modifications of the\n * generated schema, e.g. to customize added third-party types, use the\n * [`createResolvers`](/docs/node-apis/#createResolvers) API.\n *\n * @gatsbyVersion 2.12.0\n * @param {object} $0\n * @param {object} $0.actions\n * @param {object} $0.actions.createTypes\n * @param {object} $0.actions.createFieldExtension\n * @param {object} $0.actions.addThirdPartySchema\n * @example\n * exports.createSchemaCustomization = ({ actions }) => {\n *   const { createTypes, createFieldExtension } = actions\n *\n *   createFieldExtension({\n *     name: 'shout',\n *     extend: () => ({\n *       resolve(source, args, context, info) {\n *         return String(source[info.fieldName]).toUpperCase()\n *       }\n *     })\n *   })\n *\n *   const typeDefs = `\n *     type MarkdownRemark implements Node @dontInfer {\n *       frontmatter: Frontmatter\n *     }\n *     type Frontmatter {\n *       title: String!\n *       tagline: String @shout\n *       date: Date @dateformat\n *       image: File @fileByRelativePath\n *     }\n *   `\n *   createTypes(typeDefs)\n * }\n */\nexport const createSchemaCustomization = true\n\n/**\n * Add custom field resolvers to the GraphQL schema.\n *\n * Allows adding new fields to types by providing field configs, or adding resolver\n * functions to existing fields.\n *\n * Things to note:\n * * Overriding field types is disallowed, instead use the `createTypes`\n *   action. In case of types added from third-party schemas, where this is not\n *   possible, overriding field types is allowed.\n * * New fields will not be available on `filter` and `sort` input types. Extend\n *   types defined with `createTypes` if you need this.\n * * In field configs, types can be referenced as strings.\n * * When extending a field with an existing field resolver, the original\n *   resolver function is available from `info.originalResolver`.\n * * The `createResolvers` API is called as the last step in schema generation.\n *   Thus, an intermediate schema is made available on the `intermediateSchema` property.\n *   In resolver functions themselves, it is recommended to access the final\n *   built schema from `info.schema`.\n * * Gatsby's data layer, including all internal query capabilities, is\n *   exposed on [`context.nodeModel`](/docs/node-model/). The node store can be\n *   queried directly with `getAllNodes`, `getNodeById` and `getNodesByIds`,\n *   while more advanced queries can be composed with `runQuery`. Note that\n *   `runQuery` will call field resolvers before querying, so e.g. foreign-key\n *   fields will be expanded to full nodes. The other methods on `nodeModel`\n *   don't do this.\n * * It is possible to add fields to the root `Query` type.\n * * When using the first resolver argument (`source` in the example below,\n *   often also called `parent` or `root`), take care of the fact that field\n *   resolvers can be called more than once in a query, e.g. when the field is\n *   present both in the input filter and in the selection set. This means that\n *   foreign-key fields on `source` can be either resolved or not-resolved.\n *\n * For fuller examples, see [`using-type-definitions`](https://github.com/gatsbyjs/gatsby/tree/master/examples/using-type-definitions).\n *\n * @gatsbyVersion 2.2.0\n * @param {object} $0\n * @param {GraphQLSchema} $0.intermediateSchema Current GraphQL schema\n * @param {function} $0.createResolvers Add custom resolvers to GraphQL field configs\n * @param {object} $1\n * @param {object} $1.resolvers An object map of GraphQL type names to custom resolver functions\n * @param {object} $1.options Optional createResolvers options\n * @param {object} $1.options.ignoreNonexistentTypes Silences the warning when trying to add resolvers for types that don't exist. Useful for optional extensions.\n * @example\n * exports.createResolvers = ({ createResolvers }) => {\n *   const resolvers = {\n *     Author: {\n *       fullName: {\n *         resolve: (source, args, context, info) => {\n *           return source.firstName + source.lastName\n *         }\n *       },\n *     },\n *     Query: {\n *       allRecentPosts: {\n *         type: [`BlogPost`],\n *         resolve: (source, args, context, info) => {\n *           const posts = context.nodeModel.getAllNodes({ type: `BlogPost` })\n *           const recentPosts = posts.filter(\n *             post => post.publishedAt > Date.UTC(2018, 0, 1)\n *           )\n *           return recentPosts\n *         }\n *       }\n *     }\n *   }\n *   createResolvers(resolvers)\n * }\n */\nexport const createResolvers = true\n\n/**\n * Ask compile-to-js plugins to process source to JavaScript so the query\n * runner can extract out GraphQL queries for running.\n */\nexport const preprocessSource = true\n\n/**\n * Let plugins extend/mutate the site's Babel configuration by calling\n * [`setBabelPlugin`](/docs/actions/#setBabelPlugin) or\n * [`setBabelPreset`](/docs/actions/#setBabelPreset).\n * @param {object} $0\n * @param {string} $0.stage The current build stage. One of 'develop', 'develop-html',\n * 'build-javascript', or 'build-html'\n * @param {object} $0.actions\n * @param {object} options The Babel configuration\n * @example\n * exports.onCreateBabelConfig = ({ actions }) => {\n *   actions.setBabelPlugin({\n *     name: `babel-plugin-that-i-like`,\n *     options: {}\n *   })\n * }\n */\nexport const onCreateBabelConfig = true\n\n/**\n * Let plugins extend/mutate the site's webpack configuration.\n *\n * See also the documentation for [`setWebpackConfig`](/docs/actions/#setWebpackConfig).\n *\n * @param {object} $0\n * @param {string} $0.stage The current build stage. One of 'develop', 'develop-html',\n * 'build-javascript', or 'build-html'\n * @param {function} $0.getConfig Returns the current webpack config\n * @param {object} $0.rules A set of preconfigured webpack config rules\n * @param {object} $0.loaders A set of preconfigured webpack config loaders\n * @param {object} $0.plugins A set of preconfigured webpack config plugins\n * @param {object} $0.actions\n * @example\n * exports.onCreateWebpackConfig = ({\n *  stage, getConfig, rules, loaders, actions\n * }) => {\n *   actions.setWebpackConfig({\n *     module: {\n *       rules: [\n *         {\n *           test: 'my-css',\n *           use: [loaders.style(), loaders.css()]\n *         },\n *       ],\n *     },\n *   });\n * }\n */\nexport const onCreateWebpackConfig = true\n\n/**\n * The first API called during Gatsby execution, runs as soon as plugins are loaded, before cache initialization and bootstrap preparation.\n */\nexport const onPreInit = true\n\n/**\n * Lifecycle executed in each process (one time per process). Used to store actions etc for later use.\n *\n * @example\n * let createJobV2\n * exports.unstable_onPluginInit = ({ actions }) => {\n *   // store job creation action to use it later\n *   createJobV2 = actions.createJobV2\n * }\n * @gatsbyVersion 3.9.0\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const unstable_onPluginInit = true\n\n/**\n * Called once Gatsby has initialized itself and is ready to bootstrap your site.\n */\nexport const onPreBootstrap = true\n\n/**\n * Called at the end of the bootstrap process after all other extension APIs have been called.\n */\nexport const onPostBootstrap = true\n\n/**\n * The first extension point called during the build process. Called after the bootstrap has completed but before the build steps start.\n */\nexport const onPreBuild = true\n\n/**\n * The last extension point called after all other parts of the build process\n * are complete.\n */\nexport const onPostBuild = true\n\n/**\n * Run before GraphQL queries/fragments are extracted from JavaScript files. Useful for plugins\n * to add more JavaScript files with queries/fragments e.g. from node_modules.\n *\n * See gatsby-transformer-sharp and gatsby-source-contentful for examples.\n */\nexport const onPreExtractQueries = true\n\n/**\n * Run when the `gatsby develop` server is started. It can be used for adding proxies and Express middleware\n * to the server.\n * @param {object} $0\n * @param {Express} $0.app The [Express app](https://expressjs.com/en/4x/api.html#app) used to run the dev server\n * @example\n * exports.onCreateDevServer = ({ app }) => {\n *   app.get('/hello', function (req, res) {\n *     res.send('hello world')\n *   })\n * }\n */\nexport const onCreateDevServer = true\n\n/**\n * Run during the bootstrap phase. Plugins can use this to define a schema for their options using\n * [Joi](https://joi.dev) to validate the options users pass to the plugin.\n * @gatsbyVersion 2.25.0\n * @param {object} $0\n * @param {Joi} $0.Joi The instance of [Joi](https://joi.dev) to define the schema\n * @example\n * exports.pluginOptionsSchema = ({ Joi }) => {\n *   return Joi.object({\n *     // Validate that the anonymize option is defined by the user and is a boolean\n *     anonymize: Joi.boolean().required(),\n *   })\n * }\n */\nexport const pluginOptionsSchema = true\n"],"file":"api-node-docs.js"}