{"version":3,"sources":["../../src/utils/gatsby-webpack-virtual-modules.ts"],"names":["fileContentLookup","instances","VIRTUAL_MODULES_BASE_PATH","GatsbyWebpackVirtualModules","apply","compiler","virtualModules","VirtualModulesPlugin","push","writeModule","bind","getAbsolutePathForVirtualModule","filePath","path","join","process","cwd","fileContents","adjustedFilePath","fs","outputFileSync","forEach","instance"],"mappings":";;;;;;;;;AAAA;;AACA;;AACA;;;;;;AAoBA,MAAMA,iBAAyC,GAAG,EAAlD;AACA,MAAMC,SAAqD,GAAG,EAA9D;AAEO,MAAMC,yBAAyB,GAAI,kCAAnC;;;AAEA,MAAMC,2BAAN,CAAkC;AACvCC,EAAAA,KAAK,CAACC,QAAD,EAAiB;AACpB,UAAMC,cAAc,GAAG,IAAIC,8BAAJ,CAAyBP,iBAAzB,CAAvB;AACAM,IAAAA,cAAc,CAACF,KAAf,CAAqBC,QAArB;AACAJ,IAAAA,SAAS,CAACO,IAAV,CAAe;AACbC,MAAAA,WAAW,EAAEH,cAAc,CAACG,WAAf,CAA2BC,IAA3B,CAAgCJ,cAAhC;AADA,KAAf;AAGD;;AAPsC;;;;AAUlC,SAASK,+BAAT,CAAyCC,QAAzC,EAAmE;AACxE,SAAOC,IAAI,CAACC,IAAL,CAAUC,OAAO,CAACC,GAAR,EAAV,EAAyBd,yBAAzB,EAAoDU,QAApD,CAAP;AACD;;AAEM,SAASH,WAAT,CAAqBG,QAArB,EAAuCK,YAAvC,EAAmE;AACxE,QAAMC,gBAAgB,GAAGP,+BAA+B,CAACC,QAAD,CAAxD;;AAEA,MAAIZ,iBAAiB,CAACkB,gBAAD,CAAjB,KAAwCD,YAA5C,EAA0D;AACxD;AACA;AACD,GANuE,CAQxE;AACA;;;AACAE,EAAAA,EAAE,CAACC,cAAH,CAAkBF,gBAAlB,EAAoCD,YAApC;AAEAjB,EAAAA,iBAAiB,CAACkB,gBAAD,CAAjB,GAAsCD,YAAtC;AAEAhB,EAAAA,SAAS,CAACoB,OAAV,CAAkBC,QAAQ,IAAI;AAC5BA,IAAAA,QAAQ,CAACb,WAAT,CAAqBS,gBAArB,EAAuCD,YAAvC;AACD,GAFD;AAGD","sourcesContent":["import VirtualModulesPlugin from \"webpack-virtual-modules\"\nimport * as path from \"path\"\nimport * as fs from \"fs-extra\"\n/*\n * This module allows creating virtual (in memory only) modules / files\n * that webpack compilation can access without the need to write module\n * body to actual filesystem.\n *\n * It's useful for intermediate artifacts that are not part of final builds,\n * but are used in some way to generate final ones (for example `async-requires.js`).\n *\n * Using virtual modules allow us to avoid unnecessary I/O to write/read those modules,\n * but more importantly using virtual modules give us immediate invalidation events\n * in webpack watching mode (as opposed to debounced/delayed events when filesystem is used).\n * Instant invalidation events make it much easier to work with various state transitions\n * in response to external events that are happening while `gatsby develop` is running.\n */\n\ninterface IGatsbyWebpackVirtualModulesContext {\n  writeModule: VirtualModulesPlugin[\"writeModule\"]\n}\n\nconst fileContentLookup: Record<string, string> = {}\nconst instances: Array<IGatsbyWebpackVirtualModulesContext> = []\n\nexport const VIRTUAL_MODULES_BASE_PATH = `.cache/_this_is_virtual_fs_path_`\n\nexport class GatsbyWebpackVirtualModules {\n  apply(compiler): void {\n    const virtualModules = new VirtualModulesPlugin(fileContentLookup)\n    virtualModules.apply(compiler)\n    instances.push({\n      writeModule: virtualModules.writeModule.bind(virtualModules),\n    })\n  }\n}\n\nexport function getAbsolutePathForVirtualModule(filePath: string): string {\n  return path.join(process.cwd(), VIRTUAL_MODULES_BASE_PATH, filePath)\n}\n\nexport function writeModule(filePath: string, fileContents: string): void {\n  const adjustedFilePath = getAbsolutePathForVirtualModule(filePath)\n\n  if (fileContentLookup[adjustedFilePath] === fileContents) {\n    // we already have this, no need to cause invalidation\n    return\n  }\n\n  // workaround webpack marking virtual modules as deleted because those files don't really exist\n  // so we create those files just so watchpack doesn't mark them as initially missing\n  fs.outputFileSync(adjustedFilePath, fileContents)\n\n  fileContentLookup[adjustedFilePath] = fileContents\n\n  instances.forEach(instance => {\n    instance.writeModule(adjustedFilePath, fileContents)\n  })\n}\n"],"file":"gatsby-webpack-virtual-modules.js"}