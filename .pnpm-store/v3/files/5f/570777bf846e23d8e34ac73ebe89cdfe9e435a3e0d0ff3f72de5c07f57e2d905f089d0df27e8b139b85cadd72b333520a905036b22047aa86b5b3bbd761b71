{"version":3,"sources":["../../../src/schema/infer/build-example-data.ts"],"names":["getExampleObject","fieldMap","typeName","typeConflictReporter","Object","keys","reduce","acc","key","value","buildExampleValue","path","descriptor","isArrayItem","type","conflicts","resolveWinnerType","addConflict","prepareConflictExamples","typeInfo","isMixOfDateAndString","hasOnlyEmptyStrings","example","item","exampleItemValue","nodes","multiple","linkedNodes","filter","dprops","hasKeys","result","forEach","prop","candidates","possibleTypes","length","isMixedNumber","typeNameMapper","includes","reportedValueMapper","relatedNode","find","relatedNodeList","object","itemValue","array","undefined","conflictingTypes","groups","first","map","nodeId","join","float","int","Boolean","total","date","string","empty"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { groupBy } from \"lodash\"\nimport {\n  IValueDescriptor,\n  ValueType,\n  ITypeMetadata,\n} from \"./inference-metadata\"\nimport {\n  TypeConflictReporter,\n  ITypeConflictExample,\n} from \"./type-conflict-reporter\"\n\n// See gatsby/src/schema/infer/inference-metadata.ts for the ValueDescriptor structs (-> typeInfo)\n\nconst getExampleObject = ({\n  fieldMap = {},\n  typeName,\n  typeConflictReporter,\n}: ITypeMetadata): { [k: string]: unknown } =>\n  Object.keys(fieldMap).reduce((acc, key) => {\n    const value = buildExampleValue({\n      path: `${typeName}.${key}`,\n      descriptor: fieldMap[key],\n      typeConflictReporter,\n    })\n    if (key && value !== null) {\n      acc[key] = value\n    }\n    return acc\n  }, {})\n\nconst buildExampleValue = ({\n  descriptor,\n  typeConflictReporter,\n  isArrayItem = false,\n  path = ``,\n}: {\n  descriptor: IValueDescriptor\n  typeConflictReporter?: TypeConflictReporter\n  path?: string\n  isArrayItem?: boolean\n}): unknown | null => {\n  const [type, conflicts = false] = resolveWinnerType(descriptor)\n\n  if (conflicts && typeConflictReporter) {\n    typeConflictReporter.addConflict(\n      path,\n      prepareConflictExamples(descriptor, isArrayItem)\n    )\n  }\n\n  const typeInfo = descriptor[type]\n\n  switch (type) {\n    case `null`:\n      return null\n\n    case `date`:\n    case `string`: {\n      if (isMixOfDateAndString(descriptor)) {\n        return hasOnlyEmptyStrings(descriptor) ? `1978-09-26` : `String`\n      }\n      return typeInfo.example\n    }\n\n    case `array`: {\n      const { item } = typeInfo\n      const exampleItemValue = item\n        ? buildExampleValue({\n            descriptor: item,\n            isArrayItem: true,\n            typeConflictReporter,\n            path,\n          })\n        : null\n      return exampleItemValue === null ? null : [exampleItemValue]\n    }\n\n    case `relatedNode`:\n    case `relatedNodeList`: {\n      const { nodes = {} } = typeInfo\n      return {\n        multiple: type === `relatedNodeList`,\n        linkedNodes: Object.keys(nodes).filter(key => nodes[key] > 0),\n      }\n    }\n\n    case `object`: {\n      const { dprops } = typeInfo\n      let hasKeys = false\n      const result = {}\n      Object.keys(dprops).forEach(prop => {\n        const value = buildExampleValue({\n          descriptor: dprops[prop],\n          typeConflictReporter,\n          path: `${path}.${prop}`,\n        })\n        if (value !== null) {\n          hasKeys = true\n          result[prop] = value\n        }\n      })\n      return hasKeys ? result : null\n    }\n\n    default:\n      return typeInfo.example\n  }\n}\n\nconst resolveWinnerType = (\n  descriptor: IValueDescriptor\n): [ValueType | \"null\", boolean?] => {\n  const candidates = possibleTypes(descriptor)\n  if (candidates.length === 1) {\n    return [candidates[0]]\n  }\n  if (candidates.length === 2 && isMixedNumber(descriptor)) {\n    return [`float`]\n  }\n  if (candidates.length === 2 && isMixOfDateAndString(descriptor)) {\n    return [hasOnlyEmptyStrings(descriptor) ? `date` : `string`]\n  }\n  if (candidates.length > 1) {\n    return [`null`, true]\n  }\n  return [`null`]\n}\n\nconst prepareConflictExamples = (\n  descriptor: IValueDescriptor,\n  isArrayItem: boolean\n): Array<ITypeConflictExample> => {\n  const typeNameMapper = (typeName: ValueType): string => {\n    if (typeName === `relatedNode`) {\n      return `string`\n    }\n    if (typeName === `relatedNodeList`) {\n      return `[string]`\n    }\n    return [`float`, `int`].includes(typeName) ? `number` : typeName\n  }\n  const reportedValueMapper = (typeName: ValueType): unknown => {\n    if (typeName === `relatedNode`) {\n      const { nodes } = descriptor.relatedNode ?? { nodes: {} }\n      return Object.keys(nodes).find(key => nodes[key] > 0)\n    }\n    if (typeName === `relatedNodeList`) {\n      const { nodes } = descriptor.relatedNodeList ?? { nodes: {} }\n      return Object.keys(nodes).filter(key => nodes[key] > 0)\n    }\n    if (typeName === `object`) {\n      return getExampleObject({\n        typeName,\n        fieldMap: descriptor!.object!.dprops,\n      })\n    }\n    if (typeName === `array`) {\n      const itemValue = buildExampleValue({\n        descriptor: descriptor!.array!.item,\n        isArrayItem: true,\n      })\n      return itemValue === null || itemValue === undefined ? [] : [itemValue]\n    }\n    return descriptor[typeName]?.example\n  }\n  const conflictingTypes = possibleTypes(descriptor)\n\n  if (isArrayItem) {\n    // Differentiate conflict examples by node they were first seen in.\n    // See Caveats section in the header of the ./inference-metadata.ts\n    const groups = groupBy(\n      conflictingTypes,\n      type => descriptor[type]?.first || ``\n    )\n    return Object.keys(groups).map(nodeId => {\n      return {\n        type: `[${groups[nodeId].map(typeNameMapper).join(`,`)}]`,\n        value: groups[nodeId].map(reportedValueMapper),\n      }\n    })\n  }\n\n  return conflictingTypes.map(type => {\n    return {\n      type: typeNameMapper(type),\n      value: reportedValueMapper(type),\n    }\n  })\n}\n\nconst isMixedNumber = (descriptor: IValueDescriptor): boolean => {\n  const { float, int } = descriptor\n  return Boolean(float?.total) && Boolean(int?.total)\n}\n\nconst isMixOfDateAndString = (descriptor: IValueDescriptor): boolean => {\n  const { date, string } = descriptor\n  return Boolean(date?.total) && Boolean(string?.total)\n}\n\nconst hasOnlyEmptyStrings = (descriptor: IValueDescriptor): boolean => {\n  const { string } = descriptor\n  return string !== undefined && string?.empty === string?.total\n}\n\nconst possibleTypes = (descriptor: IValueDescriptor = {}): Array<ValueType> =>\n  Object.keys(descriptor).filter(\n    type => descriptor[type].total > 0\n  ) as Array<ValueType>\n\nexport { getExampleObject }\n"],"file":"build-example-data.js"}