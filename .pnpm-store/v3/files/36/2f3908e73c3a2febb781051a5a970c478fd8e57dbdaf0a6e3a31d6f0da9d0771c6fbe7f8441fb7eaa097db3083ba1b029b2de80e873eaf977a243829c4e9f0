{"version":3,"sources":["../../src/bootstrap/redirects-writer.ts"],"names":["lastHash","bootstrapFinished","writeRedirects","program","redirects","pages","store","getState","redirectMatchingPageWarnings","browserRedirects","redirect","alternativePath","fromPath","endsWith","substr","length","hasSamePage","has","push","toPath","redirectInBrowser","ignoreCase","toLowerCase","reporter","warn","join","newHash","crypto","createHash","update","JSON","stringify","digest","fs","writeFile","directory","debouncedWriteRedirects","_","debounce","startRedirectListener","emitter","on"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA;;AACA;;AAEA,IAAIA,QAAuB,GAAG,IAA9B;AACA,IAAIC,iBAAiB,GAAG,KAAxB;;AAEO,MAAMC,cAAc,GAAG,YAA2B;AACvDD,EAAAA,iBAAiB,GAAG,IAApB;;AAEA,QAAM;AAAEE,IAAAA,OAAF;AAAWC,IAAAA,SAAX;AAAsBC,IAAAA;AAAtB,MAAgCC,aAAMC,QAAN,EAAtC;;AAEA,QAAMC,4BAA2C,GAAG,EAApD;AACA,QAAMC,gBAAkC,GAAG,EAA3C;;AAEA,OAAK,MAAMC,QAAX,IAAuBN,SAAvB,EAAkC;AAChC,UAAMO,eAAe,GAAGD,QAAQ,CAACE,QAAT,CAAkBC,QAAlB,CAA4B,GAA5B,IACpBH,QAAQ,CAACE,QAAT,CAAkBE,MAAlB,CAAyB,CAAzB,EAA4BJ,QAAQ,CAACE,QAAT,CAAkBG,MAAlB,GAA2B,CAAvD,CADoB,GAEpBL,QAAQ,CAACE,QAAT,GAAqB,GAFzB;AAIA,QAAII,WAAJ;;AAEA,QACE,CAACA,WAAW,GAAGX,KAAK,CAACY,GAAN,CAAUP,QAAQ,CAACE,QAAnB,CAAf,KACAP,KAAK,CAACY,GAAN,CAAUN,eAAV,CAFF,EAGE;AACAH,MAAAA,4BAA4B,CAACU,IAA7B,CACG,aACCF,WAAW,GAAGN,QAAQ,CAACE,QAAZ,GAAuBD,eACnC,oBAAmBD,QAAQ,CAACE,QAAS,SAAQF,QAAQ,CAACS,MAAO,GAHhE;AAKD,KAhB+B,CAiBhC;;;AACA,QAAIT,QAAQ,CAACU,iBAAb,EAAgC;AAC9BX,MAAAA,gBAAgB,CAACS,IAAjB,CAAsB,EACpB,GAAGR,QADiB;AAEpBE,QAAAA,QAAQ,EAAEF,QAAQ,CAACW,UAAT,GACNX,QAAQ,CAACE,QAAT,CAAkBU,WAAlB,EADM,GAENZ,QAAQ,CAACE;AAJO,OAAtB;AAMD;AACF;;AAED,MAAIJ,4BAA4B,CAACO,MAA7B,GAAsC,CAA1C,EAA6C;AAC3CQ,sBAASC,IAAT,CACG,uIAAsIhB,4BAA4B,CAACiB,IAA7B,CACpI,IADoI,CAErI,EAHJ;AAKD;;AAED,QAAMC,OAAO,GAAGC,gBACbC,UADa,CACD,KADC,EAEbC,MAFa,CAENC,IAAI,CAACC,SAAL,CAAetB,gBAAf,CAFM,EAGbuB,MAHa,CAGL,KAHK,CAAhB;;AAKA,MAAIN,OAAO,KAAK1B,QAAhB,EAA0B;AACxB;AACD;;AAEDA,EAAAA,QAAQ,GAAG0B,OAAX;AAEA,QAAMO,iBAAGC,SAAH,CACJ,+BAAS/B,OAAO,CAACgC,SAAjB,EAA6B,uBAA7B,CADI,EAEJL,IAAI,CAACC,SAAL,CAAetB,gBAAf,EAAiC,IAAjC,EAAuC,CAAvC,CAFI,CAAN;AAID,CA3DM;;;;AA6DP,MAAM2B,uBAAuB,GAAGC,gBAAEC,QAAF,CAAW,MAAM;AAC/C;AACA,MAAIrC,iBAAJ,EAAuB;AACrBC,IAAAA,cAAc;AACf;AACF,CAL+B,EAK7B,GAL6B,CAAhC;;AAOO,MAAMqC,qBAAqB,GAAG,MAAY;AAC/CC,iBAAQC,EAAR,CAAY,iBAAZ,EAA8B,MAAM;AAClCL,IAAAA,uBAAuB;AACxB,GAFD;AAGD,CAJM","sourcesContent":["import _ from \"lodash\"\nimport crypto from \"crypto\"\nimport fs from \"fs-extra\"\nimport { store, emitter } from \"../redux\"\nimport { IRedirect } from \"../redux/types\"\nimport { joinPath } from \"gatsby-core-utils\"\nimport reporter from \"gatsby-cli/lib/reporter\"\n\nlet lastHash: string | null = null\nlet bootstrapFinished = false\n\nexport const writeRedirects = async (): Promise<void> => {\n  bootstrapFinished = true\n\n  const { program, redirects, pages } = store.getState()\n\n  const redirectMatchingPageWarnings: Array<string> = []\n  const browserRedirects: Array<IRedirect> = []\n\n  for (const redirect of redirects) {\n    const alternativePath = redirect.fromPath.endsWith(`/`)\n      ? redirect.fromPath.substr(0, redirect.fromPath.length - 1)\n      : redirect.fromPath + `/`\n\n    let hasSamePage: boolean\n\n    if (\n      (hasSamePage = pages.has(redirect.fromPath)) ||\n      pages.has(alternativePath)\n    ) {\n      redirectMatchingPageWarnings.push(\n        ` - page: \"${\n          hasSamePage ? redirect.fromPath : alternativePath\n        }\" and redirect: \"${redirect.fromPath}\" -> \"${redirect.toPath}\"`\n      )\n    }\n    // Filter for redirects that are meant for the browser.\n    if (redirect.redirectInBrowser) {\n      browserRedirects.push({\n        ...redirect,\n        fromPath: redirect.ignoreCase\n          ? redirect.fromPath.toLowerCase()\n          : redirect.fromPath,\n      })\n    }\n  }\n\n  if (redirectMatchingPageWarnings.length > 0) {\n    reporter.warn(\n      `There are routes that match both page and redirect. It will result in page not being accessible; this is probably not intentional:\\n${redirectMatchingPageWarnings.join(\n        `\\n`\n      )}`\n    )\n  }\n\n  const newHash = crypto\n    .createHash(`md5`)\n    .update(JSON.stringify(browserRedirects))\n    .digest(`hex`)\n\n  if (newHash === lastHash) {\n    return\n  }\n\n  lastHash = newHash\n\n  await fs.writeFile(\n    joinPath(program.directory, `.cache/redirects.json`),\n    JSON.stringify(browserRedirects, null, 2)\n  )\n}\n\nconst debouncedWriteRedirects = _.debounce(() => {\n  // Don't write redirects again until bootstrap has finished.\n  if (bootstrapFinished) {\n    writeRedirects()\n  }\n}, 250)\n\nexport const startRedirectListener = (): void => {\n  emitter.on(`CREATE_REDIRECT`, () => {\n    debouncedWriteRedirects()\n  })\n}\n"],"file":"redirects-writer.js"}