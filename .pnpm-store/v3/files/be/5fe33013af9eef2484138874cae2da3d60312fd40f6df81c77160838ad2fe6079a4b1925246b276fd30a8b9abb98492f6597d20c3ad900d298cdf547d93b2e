{"version":3,"sources":["../../src/utils/develop-preload-headers.ts"],"names":["appendPreloadHeaders","requestPath","res","append","page","store","getState","pagePathsToPreload","includes","path","unshift","staticQueriesToPreload","Set","pagePath","join","encodeURI","pageData","program","directory","staticQueryHash","staticQueryHashes","add","e"],"mappings":";;;;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;AAEA;AACA;AACA;AACA;AACA;AACO,eAAeA,oBAAf,CACLC,WADK,EAELC,GAFK,EAGU;AACf;AACA;AACAA,EAAAA,GAAG,CAACC,MAAJ,CAAY,MAAZ,EAAoB,uCAApB;AACAD,EAAAA,GAAG,CAACC,MAAJ,CAAY,MAAZ,EAAoB,mDAApB;AAEA,QAAMC,IAAI,GAAG,oCAAeC,aAAMC,QAAN,EAAf,EAAiCL,WAAjC,EAA8C,IAA9C,CAAb,CANe,CAOf;AACA;;AACA,MAAIG,IAAJ,EAAU;AACR;AACAF,IAAAA,GAAG,CAACC,MAAJ,CACG,MADH,EAEG,iEAFH,EAFQ,CAOR;AACA;;AACA,UAAMI,kBAAkB,GAAG,CAAE,WAAF,EAAe,gBAAf,CAA3B;;AACA,QAAI,CAACA,kBAAkB,CAACC,QAAnB,CAA4BJ,IAAI,CAACK,IAAjC,CAAL,EAA6C;AAC3C;AACAF,MAAAA,kBAAkB,CAACG,OAAnB,CAA2BN,IAAI,CAACK,IAAhC;AACD;;AAED,UAAME,sBAAsB,GAAG,IAAIC,GAAJ,EAA/B;;AACA,SAAK,MAAMC,QAAX,IAAuBN,kBAAvB,EAA2C;AACzCL,MAAAA,GAAG,CAACC,MAAJ,CACG,MADH,EAEG,KAAIM,IAAI,CAACK,IAAL,CACF,WADE,EAEHC,SAAS,CAAC,oCAAcF,QAAd,CAAD,CAFN,EAGF,gBAHE,CAIH,wCANJ;;AASA,UAAI;AACF,cAAMG,QAAQ,GAAG,MAAM,4BACrBP,IAAI,CAACK,IAAL,CAAUT,aAAMC,QAAN,GAAiBW,OAAjB,CAAyBC,SAAnC,EAA+C,QAA/C,CADqB,EAErBL,QAFqB,CAAvB,CADE,CAMF;AACA;;AACA,aAAK,MAAMM,eAAX,IAA8BH,QAAQ,CAACI,iBAAvC,EAA0D;AACxDT,UAAAA,sBAAsB,CAACU,GAAvB,CAA2BF,eAA3B;AACD;AACF,OAXD,CAWE,OAAOG,CAAP,EAAU,CACV;AACA;AACA;AACD;AACF,KA1CO,CA4CR;;;AACA,SAAK,MAAMH,eAAX,IAA8BR,sBAA9B,EAAsD;AACpDT,MAAAA,GAAG,CAACC,MAAJ,CACG,MADH,EAEG,oBAAmBgB,eAAgB,6CAFtC;AAID;AACF,GAnDD,MAmDO,CACL;AACA;AACD;AACF","sourcesContent":["import { Response } from \"express\"\nimport * as path from \"path\"\nimport { fixedPagePath } from \"gatsby-core-utils\"\nimport { findPageByPath } from \"./find-page-by-path\"\nimport { readPageData } from \"./page-data\"\nimport { store } from \"../redux\"\n\n/**\n * Add preload link headers to responses for .html files. This allows browser to schedule fetching critical resources\n * to render a page faster. Without them it would result in network waterfall (fetch js script -> parse and execute -> start downloading data)\n * With them we can start downloading data before JS executes.\n */\nexport async function appendPreloadHeaders(\n  requestPath: string,\n  res: Response\n): Promise<void> {\n  // add common.js and socket.io.js preload headers\n  // TODO: make socket.io part not blocking - we don't need it anymore to render the page\n  res.append(`Link`, `</commons.js>; rel=preload; as=script`)\n  res.append(`Link`, `</socket.io/socket.io.js>; rel=preload; as=script`)\n\n  const page = findPageByPath(store.getState(), requestPath, true)\n  // we fallback to 404 pages - so there should always be a page (at worst dev-404)\n  // this is just sanity check to not crash server in case it doesn't find anything\n  if (page) {\n    // add app-data.json preload\n    res.append(\n      `Link`,\n      `</page-data/app-data.json>; rel=preload; as=fetch ; crossorigin`\n    )\n\n    // add page-data.json preload\n    // our runtime also demands 404 and dev-404 page-data to be fetched to even render (see cache-dir/app.js)\n    const pagePathsToPreload = [`/404.html`, `/dev-404-page/`]\n    if (!pagePathsToPreload.includes(page.path)) {\n      // let's make sure page path is first one (order shouldn't matter, just for reasonable order)\n      pagePathsToPreload.unshift(page.path)\n    }\n\n    const staticQueriesToPreload = new Set<string>()\n    for (const pagePath of pagePathsToPreload) {\n      res.append(\n        `Link`,\n        `</${path.join(\n          `page-data`,\n          encodeURI(fixedPagePath(pagePath)),\n          `page-data.json`\n        )}>; rel=preload; as=fetch ; crossorigin`\n      )\n\n      try {\n        const pageData = await readPageData(\n          path.join(store.getState().program.directory, `public`),\n          pagePath\n        )\n\n        // iterate over needed static queries and add them to Set of static queries to preload\n        // Set will guarantee uniqueness in case queries are shared by requested page and 404 page.\n        for (const staticQueryHash of pageData.staticQueryHashes) {\n          staticQueriesToPreload.add(staticQueryHash)\n        }\n      } catch (e) {\n        // there might be timing reasons why this fails - page-data file is not created yet\n        // as page was just recently added (so page exists already but page-data doesn't yet)\n        // in those cases we just do nothing\n      }\n    }\n\n    // append accumulated static queries from pages we load\n    for (const staticQueryHash of staticQueriesToPreload) {\n      res.append(\n        `Link`,\n        `</page-data/sq/d/${staticQueryHash}.json>; rel=preload; as=fetch ; crossorigin`\n      )\n    }\n  } else {\n    // should we track cases when there is actually nothing returned to find cases\n    // where we don't add preload headers if above assumption turns out to be wrong?\n  }\n}\n"],"file":"develop-preload-headers.js"}