{"version":3,"sources":["../../../src/schema/types/type-defs.js"],"names":["parse","Kind","GraphQLASTNodeKind","require","inferExtensionName","dontInferExtensionName","report","isASTDocument","typeOrTypeDef","kind","DOCUMENT","parseTypeDef","error","reportParsingError","message","source","locations","length","codeFrameColumns","frame","body","start","linesAbove","linesBelow","panic","typesWithoutInference","typeNames","definitions","forEach","def","directives","directive","name","value","push","config","extensions","module","exports"],"mappings":"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","sourcesContent":["const { parse, Kind: GraphQLASTNodeKind } = require(`graphql`)\nimport { isGatsbyType } from \"./type-builders\"\nconst { inferExtensionName, dontInferExtensionName } = require(`../extensions`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nconst isASTDocument = typeOrTypeDef =>\n  typeof typeOrTypeDef === `object` &&\n  typeOrTypeDef.kind &&\n  GraphQLASTNodeKind.DOCUMENT === typeOrTypeDef.kind\n\n/**\n * Parses type definition represented as an SDL string into an AST Document.\n * Type definitions of other formats (other than SDL) are returned as is\n */\nconst parseTypeDef = typeOrTypeDef => {\n  if (typeof typeOrTypeDef === `string`) {\n    try {\n      return parse(typeOrTypeDef)\n    } catch (error) {\n      reportParsingError(error)\n    }\n  }\n  return typeOrTypeDef\n}\n\nconst reportParsingError = error => {\n  const { message, source, locations } = error\n\n  if (source && locations && locations.length) {\n    const { codeFrameColumns } = require(`@babel/code-frame`)\n\n    const frame = codeFrameColumns(\n      source.body,\n      { start: locations[0] },\n      { linesAbove: 5, linesBelow: 5 }\n    )\n    report.panic(\n      `Encountered an error parsing the provided GraphQL type definitions:\\n` +\n        message +\n        `\\n\\n` +\n        frame +\n        `\\n`\n    )\n  } else {\n    throw error\n  }\n}\n\n/**\n * Given a type definition, collects type names that should skip the inference process\n */\nconst typesWithoutInference = (typeNames = [], typeOrTypeDef) => {\n  if (typeof typeOrTypeDef === `string`) {\n    typeOrTypeDef = parseTypeDef(typeOrTypeDef)\n  }\n  if (isASTDocument(typeOrTypeDef)) {\n    typeOrTypeDef.definitions.forEach(def => {\n      if (!def.directives) return\n\n      def.directives.forEach(directive => {\n        if (directive.name.value === dontInferExtensionName && def.name.value) {\n          typeNames.push(def.name.value)\n        }\n      })\n    })\n    return typeNames\n  }\n  if (isGatsbyType(typeOrTypeDef) && typeOrTypeDef.config) {\n    const { extensions = {}, name } = typeOrTypeDef.config\n    if (\n      name &&\n      (extensions[dontInferExtensionName] ||\n        extensions[inferExtensionName] === false)\n    ) {\n      typeNames.push(name)\n    }\n  }\n  return typeNames\n}\n\nmodule.exports = {\n  parseTypeDef,\n  reportParsingError,\n  typesWithoutInference,\n  isASTDocument,\n}\n"],"file":"type-defs.js"}