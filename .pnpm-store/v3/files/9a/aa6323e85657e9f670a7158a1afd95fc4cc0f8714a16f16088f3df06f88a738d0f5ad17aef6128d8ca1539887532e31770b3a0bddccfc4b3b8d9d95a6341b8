{"version":3,"sources":["../../../src/schema/types/filter.ts"],"names":["SEARCHABLE_ENUM","SEARCHABLE","NOT_SEARCHABLE","DEPRECATED_SEARCHABLE","getQueryOperatorListInput","schemaComposer","inputTypeComposer","typeName","getTypeName","replace","getOrCreateITC","itc","addFields","elemMatch","removeEmptyFields","cache","Set","convert","has","add","fields","getFields","nonEmptyFields","Object","keys","forEach","fieldName","fieldITC","type","InputTypeComposer","convertedITC","getFieldNames","length","setFields","EQ","NE","GT","GTE","LT","LTE","IN","NIN","REGEX","GLOB","ALLOWED_OPERATORS","Boolean","Date","Float","ID","Int","JSON","String","Enum","CustomScalar","ARRAY_OPERATORS","getOperatorFields","fieldType","operators","result","op","includes","isBuiltInScalarType","GraphQLDate","GraphQLJSON","getQueryOperatorInput","GraphQLEnumType","name","typeComposer","filterInputComposer","deprecationReason","inputTypeName","derivedTypeName","getITC","GraphQLInputObjectType","fieldNames","convertedFields","fieldConfig","getFieldConfig","searchable","UnionTypeComposer","ScalarTypeComposer","undefined","getFieldExtension","getAnyTC","operatorsInputTC","isListType","GraphQLList","operatorFields","getFilterInput","getInputTypeComposer","hasField","getFieldType","extendField","filterInputTC"],"mappings":"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","sourcesContent":["import {\n  getNamedType,\n  getNullableType,\n  GraphQLInputObjectType,\n  GraphQLEnumType,\n  GraphQLList,\n  isSpecifiedScalarType,\n  GraphQLScalarType,\n} from \"graphql\"\nimport { addDerivedType } from \"./derived-types\"\nimport {\n  InputTypeComposer,\n  GraphQLJSON,\n  SchemaComposer,\n  ObjectTypeComposer,\n  EnumTypeComposer,\n  InterfaceTypeComposer,\n  UnionTypeComposer,\n  ScalarTypeComposer,\n} from \"graphql-compose\"\nimport { GraphQLDate } from \"./date\"\n\ntype Context = any\n\ntype AnyComposeType<TContext> =\n  | ObjectTypeComposer<any, TContext>\n  | InputTypeComposer<TContext>\n  | EnumTypeComposer<TContext>\n  | InterfaceTypeComposer<any, TContext>\n  | UnionTypeComposer<any, TContext>\n  | ScalarTypeComposer<TContext>\n\nexport const SEARCHABLE_ENUM = {\n  SEARCHABLE: `SEARCHABLE`,\n  NOT_SEARCHABLE: `NON_SEARCHABLE`,\n  DEPRECATED_SEARCHABLE: `DERPECATED_SEARCHABLE`,\n} as const\n\nconst getQueryOperatorListInput = ({\n  schemaComposer,\n  inputTypeComposer,\n}: {\n  schemaComposer: SchemaComposer<any>\n  inputTypeComposer: InputTypeComposer\n}): InputTypeComposer => {\n  const typeName = inputTypeComposer.getTypeName().replace(/Input/, `ListInput`)\n  return schemaComposer.getOrCreateITC(typeName, itc => {\n    itc.addFields({\n      elemMatch: inputTypeComposer,\n    })\n  })\n}\n\nconst removeEmptyFields = (\n  { inputTypeComposer }: { inputTypeComposer: InputTypeComposer },\n  cache = new Set()\n): InputTypeComposer => {\n  const convert = (itc: InputTypeComposer): InputTypeComposer => {\n    if (cache.has(itc)) {\n      return itc\n    }\n    cache.add(itc)\n    const fields = itc.getFields()\n    const nonEmptyFields = {}\n    Object.keys(fields).forEach(fieldName => {\n      const fieldITC = fields[fieldName].type\n      if (fieldITC instanceof InputTypeComposer) {\n        const convertedITC = convert(fieldITC)\n        if (convertedITC.getFieldNames().length) {\n          nonEmptyFields[fieldName] = convertedITC\n        }\n      } else {\n        nonEmptyFields[fieldName] = fieldITC\n      }\n    })\n    itc.setFields(nonEmptyFields)\n    return itc\n  }\n  return convert(inputTypeComposer)\n}\n\nconst EQ = `eq`\nconst NE = `ne`\nconst GT = `gt`\nconst GTE = `gte`\nconst LT = `lt`\nconst LTE = `lte`\nconst IN = `in`\nconst NIN = `nin`\nconst REGEX = `regex`\nconst GLOB = `glob`\n\nconst ALLOWED_OPERATORS = {\n  Boolean: [EQ, NE, IN, NIN],\n  Date: [EQ, NE, GT, GTE, LT, LTE, IN, NIN],\n  Float: [EQ, NE, GT, GTE, LT, LTE, IN, NIN],\n  ID: [EQ, NE, IN, NIN],\n  Int: [EQ, NE, GT, GTE, LT, LTE, IN, NIN],\n  JSON: [EQ, NE, IN, NIN, REGEX, GLOB],\n  String: [EQ, NE, IN, NIN, REGEX, GLOB],\n  Enum: [EQ, NE, IN, NIN],\n  CustomScalar: [EQ, NE, IN, NIN],\n}\n\ntype TypeName = keyof typeof ALLOWED_OPERATORS\n\nconst ARRAY_OPERATORS = [IN, NIN]\n\nconst getOperatorFields = (\n  fieldType: string,\n  operators: Array<string>\n): Record<string, string | Array<string>> => {\n  const result = {}\n  operators.forEach(op => {\n    if (ARRAY_OPERATORS.includes(op)) {\n      result[op] = [fieldType]\n    } else {\n      result[op] = fieldType\n    }\n  })\n  return result\n}\n\nconst isBuiltInScalarType = (type: any): type is GraphQLScalarType =>\n  isSpecifiedScalarType(type) || type === GraphQLDate || type === GraphQLJSON\n\nconst getQueryOperatorInput = ({\n  schemaComposer,\n  type,\n}: {\n  schemaComposer: SchemaComposer<Context>\n  type: any\n}): InputTypeComposer => {\n  let typeName: TypeName\n  if (type instanceof GraphQLEnumType) {\n    typeName = `Enum`\n  } else if (isBuiltInScalarType(type)) {\n    typeName = type.name as Exclude<TypeName, \"Enum\" | \"CustomScalar\">\n  } else {\n    typeName = `CustomScalar`\n  }\n  const operators = ALLOWED_OPERATORS[typeName]\n  return schemaComposer.getOrCreateITC(type.name + `QueryOperatorInput`, itc =>\n    itc.addFields(getOperatorFields(type, operators))\n  )\n}\n\nconst convert = ({\n  schemaComposer,\n  typeComposer,\n  inputTypeComposer,\n  filterInputComposer,\n  deprecationReason,\n}: {\n  schemaComposer: SchemaComposer<Context>\n  typeComposer: AnyComposeType<Context>\n  inputTypeComposer: InputTypeComposer<Context>\n  filterInputComposer?: InputTypeComposer<Context>\n  deprecationReason?: any\n}): InputTypeComposer<Context> => {\n  const inputTypeName = inputTypeComposer\n    .getTypeName()\n    .replace(/Input$/, `FilterInput`)\n\n  addDerivedType({ typeComposer, derivedTypeName: inputTypeName })\n\n  let convertedITC\n  if (filterInputComposer) {\n    convertedITC = filterInputComposer\n  } else if (schemaComposer.has(inputTypeName)) {\n    return schemaComposer.getITC(inputTypeName)\n  } else {\n    convertedITC = new InputTypeComposer(\n      new GraphQLInputObjectType({\n        name: inputTypeName,\n        fields: {},\n      }),\n      schemaComposer\n    )\n  }\n\n  schemaComposer.add(convertedITC)\n\n  const fieldNames = inputTypeComposer.getFieldNames()\n  const convertedFields = {}\n  fieldNames.forEach(fieldName => {\n    const fieldConfig = inputTypeComposer.getFieldConfig(fieldName)\n    const type = getNamedType(fieldConfig.type)\n    const searchable =\n      typeComposer instanceof UnionTypeComposer ||\n      typeComposer instanceof ScalarTypeComposer\n        ? undefined\n        : typeComposer.getFieldExtension(fieldName, `searchable`)\n\n    if (searchable === SEARCHABLE_ENUM.NOT_SEARCHABLE) {\n      return\n    } else if (searchable === SEARCHABLE_ENUM.DEPRECATED_SEARCHABLE) {\n      deprecationReason = `Filtering on fields that need arguments to resolve is deprecated.`\n    }\n\n    if (type instanceof GraphQLInputObjectType) {\n      // Input type composers has names `FooInput`, get the type associated\n      // with it\n      const typeComposer = schemaComposer.getAnyTC(\n        type.name.replace(/Input$/, ``)\n      )\n      const itc = new InputTypeComposer(type, schemaComposer)\n\n      const operatorsInputTC = convert({\n        schemaComposer,\n        typeComposer,\n        inputTypeComposer: itc,\n        deprecationReason,\n      })\n\n      // TODO: array of arrays?\n      const isListType =\n        getNullableType(fieldConfig.type) instanceof GraphQLList\n\n      // elemMatch operator\n      convertedFields[fieldName] = isListType\n        ? getQueryOperatorListInput({\n            schemaComposer,\n            inputTypeComposer: operatorsInputTC,\n          })\n        : operatorsInputTC\n    } else {\n      // GraphQLScalarType || GraphQLEnumType\n      const operatorFields = getQueryOperatorInput({ schemaComposer, type })\n      if (operatorFields) {\n        convertedFields[fieldName] = operatorFields\n      }\n    }\n\n    if (convertedFields[fieldName]) {\n      convertedFields[fieldName].deprecationReason = deprecationReason\n    }\n  })\n\n  convertedITC.addFields(convertedFields)\n  return convertedITC\n}\n\nexport const getFilterInput = ({\n  schemaComposer,\n  typeComposer,\n}: {\n  schemaComposer: SchemaComposer<Context>\n  typeComposer: ObjectTypeComposer<Context> | InterfaceTypeComposer<Context>\n}): InputTypeComposer => {\n  const typeName = typeComposer.getTypeName()\n  const filterInputComposer = schemaComposer.getOrCreateITC(\n    `${typeName}FilterInput`\n  )\n  const inputTypeComposer = typeComposer.getInputTypeComposer()\n\n  // TODO: In Gatsby v2, the NodeInput.id field is of type String, not ID.\n  // Remove this workaround for v3.\n  if (\n    inputTypeComposer?.hasField(`id`) &&\n    getNamedType(inputTypeComposer.getFieldType(`id`)).name === `ID`\n  ) {\n    inputTypeComposer.extendField(`id`, { type: `String` })\n  }\n\n  const filterInputTC = convert({\n    schemaComposer,\n    typeComposer,\n    inputTypeComposer,\n    filterInputComposer,\n  })\n\n  return removeEmptyFields({ inputTypeComposer: filterInputTC })\n}\n"],"file":"filter.js"}