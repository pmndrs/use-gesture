{"version":3,"sources":["../../src/commands/build-utils.ts"],"names":["checkFolderIsEmpty","path","fs","existsSync","readdirSync","length","checkAndRemoveEmptyDir","publicDir","pagePath","pageHtmlDirectory","dirname","pageDataDirectory","join","removeSync","sortedPageKeysByNestedLevel","pageKeys","sort","a","b","currentPagePathValue","split","previousPagePathValue","removePageFiles","removePages","map","removePromise","then","store","dispatch","type","payload","removePageDataList","Promise","all","forEach","FSisCaseInsensitive","normalizePagePath","toLowerCase","endsWith","slice","pageGenerationActionPriority","regenerate","reuse","delete","calcDirtyHtmlFiles","state","toRegenerate","Set","toDelete","toCleanupFromTrackedState","normalizedPagePathToAction","Map","markActionForPage","action","normalizedPagePath","previousAction","get","overwritePreviousAction","previousActionPriority","currentActionPriority","add","actualPath","set","html","unsafeBuiltinWasUsedInSSR","reporter","warn","trackedHtmlFiles","htmlFile","page","pages","isDeleted","mode","dirty","Array","from","markHtmlDirtyIfResultOfUsedStaticQueryChanged","getState","dirtyStaticQueryResults","trackedStaticQueryResults","staticQueryResultState","staticQueryHash","dirtyTemplates","staticQueriesByTemplate","staticQueryHashes","componentPath","dirtyStaticQueryHash","includes","dirtyPages","dirtyTemplate","component","components"],"mappings":"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","sourcesContent":["import fs from \"fs-extra\"\nimport path from \"path\"\nimport { platform } from \"os\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport {\n  remove as removePageHtmlFile,\n  generateHtmlPath,\n  fixedPagePath,\n} from \"gatsby-core-utils\"\nimport { removePageData } from \"../utils/page-data\"\nimport { store } from \"../redux\"\nimport { IGatsbyState } from \"../redux/types\"\n\nconst checkFolderIsEmpty = (path: string): boolean =>\n  fs.existsSync(path) && !fs.readdirSync(path).length\n\nconst checkAndRemoveEmptyDir = (publicDir: string, pagePath: string): void => {\n  const pageHtmlDirectory = path.dirname(generateHtmlPath(publicDir, pagePath))\n  const pageDataDirectory = path.join(\n    publicDir,\n    `page-data`,\n    fixedPagePath(pagePath)\n  )\n  // if page's folder is empty also remove matching page-data folder\n  if (checkFolderIsEmpty(pageHtmlDirectory)) {\n    fs.removeSync(pageHtmlDirectory)\n  }\n  if (checkFolderIsEmpty(pageDataDirectory)) {\n    fs.removeSync(pageDataDirectory)\n  }\n}\n\nconst sortedPageKeysByNestedLevel = (pageKeys: Array<string>): Array<string> =>\n  pageKeys.sort((a, b) => {\n    const currentPagePathValue = a.split(`/`).length\n    const previousPagePathValue = b.split(`/`).length\n    return previousPagePathValue - currentPagePathValue\n  })\n\nexport const removePageFiles = async (\n  publicDir: string,\n  pageKeys: Array<string>\n): Promise<void> => {\n  const removePages = pageKeys.map(pagePath => {\n    const removePromise = removePageHtmlFile({ publicDir }, pagePath)\n    removePromise.then(() => {\n      store.dispatch({\n        type: `HTML_REMOVED`,\n        payload: pagePath,\n      })\n    })\n    return removePromise\n  })\n\n  const removePageDataList = pageKeys.map(pagePath =>\n    removePageData(publicDir, pagePath)\n  )\n\n  return Promise.all([...removePages, ...removePageDataList]).then(() => {\n    // Sort removed pageKeys by nested directories and remove if empty.\n    sortedPageKeysByNestedLevel(pageKeys).forEach(pagePath => {\n      checkAndRemoveEmptyDir(publicDir, pagePath)\n    })\n  })\n}\n\nconst FSisCaseInsensitive = platform() === `win32` || platform() === `darwin`\nfunction normalizePagePath(path: string): string {\n  if (path === `/`) {\n    return `/`\n  }\n\n  if (FSisCaseInsensitive) {\n    // e.g. /TEST/ and /test/ would produce \"same\" artifacts on case insensitive\n    // file systems\n    path = path.toLowerCase()\n  }\n\n  return path.endsWith(`/`) ? path.slice(0, -1) : path\n}\n\ntype PageGenerationAction = \"delete\" | \"regenerate\" | \"reuse\"\nconst pageGenerationActionPriority: Record<PageGenerationAction, number> = {\n  // higher the number, higher the priority\n  regenerate: 2,\n  reuse: 1,\n  delete: 0,\n}\n\nexport function calcDirtyHtmlFiles(state: IGatsbyState): {\n  toRegenerate: Array<string>\n  toDelete: Array<string>\n  toCleanupFromTrackedState: Set<string>\n} {\n  const toRegenerate = new Set<string>()\n  const toDelete = new Set<string>()\n  const toCleanupFromTrackedState = new Set<string>()\n  const normalizedPagePathToAction = new Map<\n    string,\n    {\n      actualPath: string\n      action: PageGenerationAction\n    }\n  >()\n\n  /**\n   * multiple page paths can result in same html and page-data filenames\n   * so we need to keep that in mind when generating list of pages\n   * to regenerate and more importantly - to delete (so we don't delete html and page-data file\n   * when path changes slightly but it would still result in same html and page-data filenames\n   * for example adding/removing trailing slash between builds or even mid build with plugins\n   * like `gatsby-plugin-remove-trailing-slashes`). Additionally similar consideration need to\n   * be accounted for cases where page paths casing on case-insensitive file systems.\n   */\n  function markActionForPage(path: string, action: PageGenerationAction): void {\n    const normalizedPagePath = normalizePagePath(path)\n\n    const previousAction = normalizedPagePathToAction.get(normalizedPagePath)\n    let overwritePreviousAction = false\n    if (previousAction) {\n      const previousActionPriority =\n        pageGenerationActionPriority[previousAction.action]\n      const currentActionPriority = pageGenerationActionPriority[action]\n\n      if (currentActionPriority > previousActionPriority) {\n        overwritePreviousAction = true\n        toCleanupFromTrackedState.add(previousAction.actualPath)\n        if (previousAction.action === `delete`) {\n          // \"reuse\" or \"regenerate\" will take over, so we should\n          // remove path from list of paths to delete\n          toDelete.delete(previousAction.actualPath)\n        }\n      }\n    }\n\n    if (!previousAction || overwritePreviousAction) {\n      normalizedPagePathToAction.set(normalizedPagePath, {\n        actualPath: path,\n        action,\n      })\n      if (action === `delete`) {\n        toDelete.add(path)\n      } else if (action === `regenerate`) {\n        toRegenerate.add(path)\n      }\n    }\n  }\n\n  if (state.html.unsafeBuiltinWasUsedInSSR) {\n    reporter.warn(\n      `Previous build used unsafe builtin method. We need to rebuild all pages`\n    )\n  }\n\n  state.html.trackedHtmlFiles.forEach(function (htmlFile, path) {\n    const page = state.pages.get(path)\n    if (htmlFile.isDeleted || !page) {\n      // FIXME: checking pages state here because pages are not persisted\n      // and because of that `isDeleted` might not be set ...\n      markActionForPage(path, `delete`)\n    } else {\n      if (_CFLAGS_.GATSBY_MAJOR === `4`) {\n        if (page.mode === `SSG`) {\n          if (htmlFile.dirty || state.html.unsafeBuiltinWasUsedInSSR) {\n            markActionForPage(path, `regenerate`)\n          } else {\n            markActionForPage(path, `reuse`)\n          }\n        }\n      } else {\n        if (htmlFile.dirty || state.html.unsafeBuiltinWasUsedInSSR) {\n          markActionForPage(path, `regenerate`)\n        } else {\n          markActionForPage(path, `reuse`)\n        }\n      }\n    }\n  })\n\n  return {\n    toRegenerate: Array.from(toRegenerate),\n    toDelete: Array.from(toDelete),\n    toCleanupFromTrackedState,\n  }\n}\n\nexport function markHtmlDirtyIfResultOfUsedStaticQueryChanged(): void {\n  const state = store.getState()\n\n  const dirtyStaticQueryResults = new Set<string>()\n  state.html.trackedStaticQueryResults.forEach(function (\n    staticQueryResultState,\n    staticQueryHash\n  ) {\n    if (staticQueryResultState.dirty) {\n      dirtyStaticQueryResults.add(staticQueryHash)\n    }\n  })\n\n  // we have dirty static query hashes - now we need to find templates that use them\n  const dirtyTemplates = new Set<string>()\n  state.staticQueriesByTemplate.forEach(function (\n    staticQueryHashes,\n    componentPath\n  ) {\n    for (const dirtyStaticQueryHash of dirtyStaticQueryResults) {\n      if (staticQueryHashes.includes(dirtyStaticQueryHash)) {\n        dirtyTemplates.add(componentPath)\n        break // we already know this template need to rebuild, no need to check rest of queries\n      }\n    }\n  })\n\n  // mark html as dirty\n  const dirtyPages = new Set<string>()\n  for (const dirtyTemplate of dirtyTemplates) {\n    const component = state.components.get(dirtyTemplate)\n    if (component) {\n      for (const page of component.pages) {\n        dirtyPages.add(page)\n      }\n    }\n  }\n\n  store.dispatch({\n    type: `HTML_MARK_DIRTY_BECAUSE_STATIC_QUERY_RESULT_CHANGED`,\n    payload: {\n      pages: dirtyPages,\n      staticQueryHashes: dirtyStaticQueryResults,\n    },\n  })\n}\n"],"file":"build-utils.js"}