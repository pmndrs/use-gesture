"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three");class t extends e.Loader{constructor(e){super(e),this.littleEndian=!0}load(t,i,s,n){const r=this,o=new e.FileLoader(r.manager);o.setPath(r.path),o.setResponseType("arraybuffer"),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(t,(function(e){try{i(r.parse(e,t))}catch(e){n?n(e):console.error(e),r.manager.itemError(t)}}),s,n)}parse(t,i){const s=e.LoaderUtils.decodeText(new Uint8Array(t)),n=function(e){const t={},i=e.search(/[\r\n]DATA\s(\S*)\s/i),s=/[\r\n]DATA\s(\S*)\s/i.exec(e.substr(i-1));if(t.data=s[1],t.headerLen=s[0].length+i,t.str=e.substr(0,t.headerLen),t.str=t.str.replace(/\#.*/gi,""),t.version=/VERSION (.*)/i.exec(t.str),t.fields=/FIELDS (.*)/i.exec(t.str),t.size=/SIZE (.*)/i.exec(t.str),t.type=/TYPE (.*)/i.exec(t.str),t.count=/COUNT (.*)/i.exec(t.str),t.width=/WIDTH (.*)/i.exec(t.str),t.height=/HEIGHT (.*)/i.exec(t.str),t.viewpoint=/VIEWPOINT (.*)/i.exec(t.str),t.points=/POINTS (.*)/i.exec(t.str),null!==t.version&&(t.version=parseFloat(t.version[1])),null!==t.fields&&(t.fields=t.fields[1].split(" ")),null!==t.type&&(t.type=t.type[1].split(" ")),null!==t.width&&(t.width=parseInt(t.width[1])),null!==t.height&&(t.height=parseInt(t.height[1])),null!==t.viewpoint&&(t.viewpoint=t.viewpoint[1]),null!==t.points&&(t.points=parseInt(t.points[1],10)),null===t.points&&(t.points=t.width*t.height),null!==t.size&&(t.size=t.size[1].split(" ").map((function(e){return parseInt(e,10)}))),null!==t.count)t.count=t.count[1].split(" ").map((function(e){return parseInt(e,10)}));else{t.count=[];for(let e=0,i=t.fields.length;e<i;e++)t.count.push(1)}t.offset={};let n=0;for(let e=0,i=t.fields.length;e<i;e++)"ascii"===t.data?t.offset[t.fields[e]]=e:(t.offset[t.fields[e]]=n,n+=t.size[e]*t.count[e]);return t.rowSize=n,t}(s),r=[],o=[],l=[];if("ascii"===n.data){const e=n.offset,t=s.substr(n.headerLen).split("\n");for(let i=0,s=t.length;i<s;i++){if(""===t[i])continue;const s=t[i].split(" ");if(void 0!==e.x&&(r.push(parseFloat(s[e.x])),r.push(parseFloat(s[e.y])),r.push(parseFloat(s[e.z]))),void 0!==e.rgb){const t=parseFloat(s[e.rgb]),i=t>>16&255,n=t>>8&255,r=t>>0&255;l.push(i/255,n/255,r/255)}void 0!==e.normal_x&&(o.push(parseFloat(s[e.normal_x])),o.push(parseFloat(s[e.normal_y])),o.push(parseFloat(s[e.normal_z])))}}if("binary_compressed"===n.data){const e=new Uint32Array(t.slice(n.headerLen,n.headerLen+8)),i=e[0],s=e[1],a=function(e,t){const i=e.length,s=new Uint8Array(t);let n,r,o,l=0,a=0;do{if(n=e[l++],n<32){if(n++,a+n>t)throw new Error("Output buffer is not large enough");if(l+n>i)throw new Error("Invalid compressed data");do{s[a++]=e[l++]}while(--n)}else{if(r=n>>5,o=a-((31&n)<<8)-1,l>=i)throw new Error("Invalid compressed data");if(7===r&&(r+=e[l++],l>=i))throw new Error("Invalid compressed data");if(o-=e[l++],a+r+2>t)throw new Error("Output buffer is not large enough");if(o<0)throw new Error("Invalid compressed data");if(o>=a)throw new Error("Invalid compressed data");do{s[a++]=s[o++]}while(2+--r)}}while(l<i);return s}(new Uint8Array(t,n.headerLen+8,i),s),p=new DataView(a.buffer),h=n.offset;for(let e=0;e<n.points;e++)void 0!==h.x&&(r.push(p.getFloat32(n.points*h.x+n.size[0]*e,this.littleEndian)),r.push(p.getFloat32(n.points*h.y+n.size[1]*e,this.littleEndian)),r.push(p.getFloat32(n.points*h.z+n.size[2]*e,this.littleEndian))),void 0!==h.rgb&&(l.push(p.getUint8(n.points*h.rgb+n.size[3]*e+0)/255),l.push(p.getUint8(n.points*h.rgb+n.size[3]*e+1)/255),l.push(p.getUint8(n.points*h.rgb+n.size[3]*e+2)/255)),void 0!==h.normal_x&&(o.push(p.getFloat32(n.points*h.normal_x+n.size[4]*e,this.littleEndian)),o.push(p.getFloat32(n.points*h.normal_y+n.size[5]*e,this.littleEndian)),o.push(p.getFloat32(n.points*h.normal_z+n.size[6]*e,this.littleEndian)))}if("binary"===n.data){const e=new DataView(t,n.headerLen),i=n.offset;for(let t=0,s=0;t<n.points;t++,s+=n.rowSize)void 0!==i.x&&(r.push(e.getFloat32(s+i.x,this.littleEndian)),r.push(e.getFloat32(s+i.y,this.littleEndian)),r.push(e.getFloat32(s+i.z,this.littleEndian))),void 0!==i.rgb&&(l.push(e.getUint8(s+i.rgb+2)/255),l.push(e.getUint8(s+i.rgb+1)/255),l.push(e.getUint8(s+i.rgb+0)/255)),void 0!==i.normal_x&&(o.push(e.getFloat32(s+i.normal_x,this.littleEndian)),o.push(e.getFloat32(s+i.normal_y,this.littleEndian)),o.push(e.getFloat32(s+i.normal_z,this.littleEndian)))}const a=new e.BufferGeometry;r.length>0&&a.setAttribute("position",new e.Float32BufferAttribute(r,3)),o.length>0&&a.setAttribute("normal",new e.Float32BufferAttribute(o,3)),l.length>0&&a.setAttribute("color",new e.Float32BufferAttribute(l,3)),a.computeBoundingSphere();const p=new e.PointsMaterial({size:.005});l.length>0?p.vertexColors=!0:p.color.setHex(16777215*Math.random());const h=new e.Points(a,p);let u=i.split("").reverse().join("");return u=/([^\/]*)/.exec(u),u=u[1].split("").reverse().join(""),h.name=u,h}}exports.PCDLoader=t;
