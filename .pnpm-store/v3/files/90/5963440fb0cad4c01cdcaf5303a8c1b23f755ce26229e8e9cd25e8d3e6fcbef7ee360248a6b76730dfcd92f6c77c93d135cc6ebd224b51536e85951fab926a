{"version":3,"sources":["../../../src/utils/tracer/zipkin-local.ts"],"names":["logger","recorder","create","HttpLogger","endpoint","zipkin","BatchRecorder","timeout","tracer","ZipkinTracer","localServiceName","serviceName","sampler","CountingSampler","traceId128Bit","kind","_processQueue","queue","length","postBody","join","response","method","body","headers","status","err","errorListenerSet","emit","Error","console","error","stop","partialSpans","forEach","span","id","_timedOut","_writeSpan"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AAGA,IAAIA,MAAJ;AACA,IAAIC,QAAJ;AAEA;AACA;AACA;AACA;;AACO,MAAMC,MAAM,GAAG,MAAoB;AACxCF,EAAAA,MAAM,GAAG,IAAIG,+BAAJ,CAAe;AACtB;AACAC,IAAAA,QAAQ,EAAG;AAFW,GAAf,CAAT;AAKAH,EAAAA,QAAQ,GAAG,IAAII,gBAAOC,aAAX,CAAyB;AAClCN,IAAAA,MADkC;AAElC;AACAO,IAAAA,OAAO,EAAE,KAAK,EAAL,GAAU,EAAV,GAAe;AAHU,GAAzB,CAAX;AAMA,QAAMC,MAAM,GAAG,IAAIC,oCAAJ,CAAiB;AAC9BC,IAAAA,gBAAgB,EAAG,QADW;AAE9BC,IAAAA,WAAW,EAAG,QAFgB;AAG9B;AACA;AACA;AACA;AACA;AACA;AACAC,IAAAA,OAAO,EAAE,IAAIP,gBAAOO,OAAP,CAAeC,eAAnB,CAAmC,CAAnC,CATqB;AAU9BC,IAAAA,aAAa,EAAE,IAVe;AAW9Bb,IAAAA,QAX8B;AAY9Bc,IAAAA,IAAI,EAAG;AAZuB,GAAjB,CAAf;AAeA,SAAOP,MAAP;AACD,CA5BM,C,CA8BP;AACA;AACA;AACA;;;;;AACA,MAAMQ,aAAa,GAAG,YAA2B;AAC/C,MAAIhB,MAAM,CAACiB,KAAP,CAAaC,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,UAAMC,QAAQ,GAAI,IAAGnB,MAAM,CAACiB,KAAP,CAAaG,IAAb,CAAmB,GAAnB,CAAuB,GAA5C;;AACA,QAAI;AACF,YAAMC,QAAQ,GAAG,MAAM,wBAAMrB,MAAM,CAACI,QAAb,EAAuB;AAC5CkB,QAAAA,MAAM,EAAG,MADmC;AAE5CC,QAAAA,IAAI,EAAEJ,QAFsC;AAG5CK,QAAAA,OAAO,EAAExB,MAAM,CAACwB,OAH4B;AAI5CjB,QAAAA,OAAO,EAAEP,MAAM,CAACO;AAJ4B,OAAvB,CAAvB;;AAOA,UAAIc,QAAQ,CAACI,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,cAAMC,GAAG,GACN,wDAAD,GACC,GAAEL,QAAQ,CAACI,MAAO,WAAUN,QAAS,EAFxC;AAIA,YAAInB,MAAM,CAAC2B,gBAAX,EAA6B3B,MAAM,CAAC4B,IAAP,CAAa,OAAb,EAAqB,IAAIC,KAAJ,CAAUH,GAAV,CAArB,EAA7B,KACKI,OAAO,CAACC,KAAR,CAAcL,GAAd;AACN;AACF,KAhBD,CAgBE,OAAOK,KAAP,EAAc;AACd,YAAML,GAAG,GAAI,6BAA4BK,KAAM,EAA/C;AACA,UAAI/B,MAAM,CAAC2B,gBAAX,EAA6B3B,MAAM,CAAC4B,IAAP,CAAa,OAAb,EAAqB,IAAIC,KAAJ,CAAUH,GAAV,CAArB,EAA7B,KACKI,OAAO,CAACC,KAAR,CAAcL,GAAd;AACN;AACF;AACF,CAzBD;AA2BA;AACA;AACA;AACA;AACA;;;AACO,MAAMM,IAAI,GAAG,YAA2B;AAC7C;AACA/B,EAAAA,QAAQ,CAACgC,YAAT,CAAsBC,OAAtB,CAA8B,CAACC,IAAD,EAAOC,EAAP,KAAc;AAC1C,QAAInC,QAAQ,CAACoC,SAAT,CAAmBF,IAAnB,CAAJ,EAA8B;AAC5BlC,MAAAA,QAAQ,CAACqC,UAAT,CAAoBF,EAApB;AACD;AACF,GAJD,EAF6C,CAQ7C;;AACA,QAAMpB,aAAa,EAAnB;AACD,CAVM","sourcesContent":["import zipkin from \"zipkin\"\nimport { HttpLogger } from \"zipkin-transport-http\"\nimport ZipkinTracer from \"zipkin-javascript-opentracing\"\nimport fetch from \"node-fetch\"\nimport { ZipkinBatchRecorder, ZipkinHttpLogger } from \"./zipkin-types\"\n\nlet logger: ZipkinHttpLogger\nlet recorder: ZipkinBatchRecorder\n\n/**\n * Create and return an open-tracing compatible tracer. See\n * https://github.com/opentracing/opentracing-javascript/blob/master/src/tracer.ts\n */\nexport const create = (): ZipkinTracer => {\n  logger = new HttpLogger({\n    // endpoint of local docker zipkin instance\n    endpoint: `http://localhost:9411/api/v1/spans`,\n  }) as ZipkinHttpLogger\n\n  recorder = new zipkin.BatchRecorder({\n    logger,\n    // timeout = 60 hours, must be longer than site's build time\n    timeout: 60 * 60 * 60 * 1000000,\n  }) as ZipkinBatchRecorder\n\n  const tracer = new ZipkinTracer({\n    localServiceName: `gatsby`,\n    serviceName: `gatsby`,\n    // Sample 1 out of 1 spans (100%). When tracing production\n    // services, it is normal to sample 1 out of 10 requests so that\n    // tracing information doesn't impact site performance. But Gatsby\n    // is a build tool and only has \"1\" request (the\n    // build). Therefore, we must set this to 100% so that spans\n    // aren't missing\n    sampler: new zipkin.sampler.CountingSampler(1),\n    traceId128Bit: true,\n    recorder,\n    kind: `client`,\n  })\n\n  return tracer\n}\n\n// Workaround for issue in Zipkin HTTP Logger where Spans are not\n// cleared off their processing queue before the node.js process\n// exits. Code is mostly the same as the zipkin processQueue\n// implementation.\nconst _processQueue = async (): Promise<void> => {\n  if (logger.queue.length > 0) {\n    const postBody = `[${logger.queue.join(`,`)}]`\n    try {\n      const response = await fetch(logger.endpoint, {\n        method: `POST`,\n        body: postBody,\n        headers: logger.headers,\n        timeout: logger.timeout,\n      })\n\n      if (response.status !== 202) {\n        const err =\n          `Unexpected response while sending Zipkin data, status:` +\n          `${response.status}, body: ${postBody}`\n\n        if (logger.errorListenerSet) logger.emit(`error`, new Error(err))\n        else console.error(err)\n      }\n    } catch (error) {\n      const err = `Error sending Zipkin data ${error}`\n      if (logger.errorListenerSet) logger.emit(`error`, new Error(err))\n      else console.error(err)\n    }\n  }\n}\n\n/**\n * Run any tracer cleanup required before the node.js process\n * exits. For Zipkin HTTP, we must manually process any spans still on\n * the queue\n */\nexport const stop = async (): Promise<void> => {\n  // First, write all partial spans to the http logger\n  recorder.partialSpans.forEach((span, id) => {\n    if (recorder._timedOut(span)) {\n      recorder._writeSpan(id)\n    }\n  })\n\n  // Then tell http logger to process all spans in its queue\n  await _processQueue()\n}\n"],"file":"zipkin-local.js"}