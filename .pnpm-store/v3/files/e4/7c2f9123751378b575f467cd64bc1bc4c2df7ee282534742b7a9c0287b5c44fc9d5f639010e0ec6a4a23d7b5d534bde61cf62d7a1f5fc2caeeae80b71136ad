{"version":3,"file":"index.cjs.js","sources":["../../../dist/schema/src/addSchemaLevelResolver.js","../../../dist/schema/src/assertResolversPresent.js","../../../dist/schema/src/attachDirectiveResolvers.js","../../../dist/schema/src/extensionDefinitions.js","../../../dist/schema/src/concatenateTypeDefs.js","../../../dist/schema/src/buildSchemaFromTypeDefinitions.js","../../../dist/schema/src/chainResolvers.js","../../../dist/schema/src/decorateWithLogger.js","../../../dist/schema/src/checkForResolveTypeResolver.js","../../../dist/schema/src/extendResolversFromInterfaces.js","../../../dist/schema/src/addResolversToSchema.js","../../../dist/schema/src/addErrorLoggingToSchema.js","../../../dist/schema/src/addCatchUndefinedToSchema.js","../../../dist/schema/src/makeExecutableSchema.js"],"sourcesContent":["import { defaultFieldResolver } from 'graphql';\nimport { ValueOrPromise } from 'value-or-promise';\nimport { mapSchema, MapperKind } from '@graphql-tools/utils';\n// wraps all resolvers of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolver\nexport function addSchemaLevelResolver(schema, fn) {\n    // TODO test that schema is a schema, fn is a function\n    const fnToRunOnlyOnce = runAtMostOncePerRequest(fn);\n    return mapSchema(schema, {\n        [MapperKind.ROOT_FIELD]: (fieldConfig, _fieldName, typeName, schema) => {\n            // XXX this should run at most once per request to simulate a true root resolver\n            // for graphql-js this is an approximation that works with queries but not mutations\n            // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n            // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n            const subscription = schema.getSubscriptionType();\n            if (subscription != null && subscription.name === typeName) {\n                return {\n                    ...fieldConfig,\n                    resolve: wrapResolver(fieldConfig.resolve, fn),\n                };\n            }\n            return {\n                ...fieldConfig,\n                resolve: wrapResolver(fieldConfig.resolve, fnToRunOnlyOnce),\n            };\n        },\n    });\n}\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(innerResolver, outerResolver) {\n    return (obj, args, ctx, info) => {\n        return new ValueOrPromise(() => outerResolver(obj, args, ctx, info))\n            .then(root => {\n            if (innerResolver != null) {\n                return innerResolver(root, args, ctx, info);\n            }\n            return defaultFieldResolver(root, args, ctx, info);\n        })\n            .resolve();\n    };\n}\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(fn) {\n    let value;\n    const randomNumber = Math.random();\n    return (root, args, ctx, info) => {\n        if (!info.operation['__runAtMostOnce']) {\n            info.operation['__runAtMostOnce'] = {};\n        }\n        if (!info.operation['__runAtMostOnce'][randomNumber]) {\n            info.operation['__runAtMostOnce'][randomNumber] = true;\n            value = fn(root, args, ctx, info);\n        }\n        return value;\n    };\n}\n//# sourceMappingURL=addSchemaLevelResolver.js.map","import { getNamedType, isScalarType } from 'graphql';\nimport { forEachField } from '@graphql-tools/utils';\nexport function assertResolversPresent(schema, resolverValidationOptions = {}) {\n    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields, } = resolverValidationOptions;\n    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n            'requireResolversForNonScalar, but not a combination of them.');\n    }\n    forEachField(schema, (field, typeName, fieldName) => {\n        // requires a resolver for *every* field.\n        if (requireResolversForAllFields) {\n            expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that has arguments\n        if (requireResolversForArgs && field.args.length > 0) {\n            expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that returns a non-scalar type\n        if (requireResolversForNonScalar !== 'ignore' && !isScalarType(getNamedType(field.type))) {\n            expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n        }\n    });\n}\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n    if (!field.resolve) {\n        const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n        if (behavior === 'error') {\n            throw new Error(message);\n        }\n        if (behavior === 'warn') {\n            // eslint-disable-next-line no-console\n            console.warn(message);\n        }\n        return;\n    }\n    if (typeof field.resolve !== 'function') {\n        throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n    }\n}\n//# sourceMappingURL=assertResolversPresent.js.map","import { defaultFieldResolver } from 'graphql';\nimport { mapSchema, MapperKind, getDirectives } from '@graphql-tools/utils';\nexport function attachDirectiveResolvers(schema, directiveResolvers) {\n    if (typeof directiveResolvers !== 'object') {\n        throw new Error(`Expected directiveResolvers to be of type object, got ${typeof directiveResolvers}`);\n    }\n    if (Array.isArray(directiveResolvers)) {\n        throw new Error('Expected directiveResolvers to be of type object, got Array');\n    }\n    return mapSchema(schema, {\n        [MapperKind.OBJECT_FIELD]: fieldConfig => {\n            const newFieldConfig = { ...fieldConfig };\n            const directives = getDirectives(schema, fieldConfig);\n            Object.keys(directives).forEach(directiveName => {\n                if (directiveResolvers[directiveName]) {\n                    const resolver = directiveResolvers[directiveName];\n                    const originalResolver = newFieldConfig.resolve != null ? newFieldConfig.resolve : defaultFieldResolver;\n                    const directiveArgs = directives[directiveName];\n                    newFieldConfig.resolve = (source, originalArgs, context, info) => {\n                        return resolver(() => new Promise((resolve, reject) => {\n                            const result = originalResolver(source, originalArgs, context, info);\n                            if (result instanceof Error) {\n                                reject(result);\n                            }\n                            resolve(result);\n                        }), source, directiveArgs, context, info);\n                    };\n                }\n            });\n            return newFieldConfig;\n        },\n    });\n}\n//# sourceMappingURL=attachDirectiveResolvers.js.map","import { Kind } from 'graphql';\nconst isExtensionNode = (def) => def.kind === Kind.OBJECT_TYPE_EXTENSION ||\n    def.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n    def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION ||\n    def.kind === Kind.UNION_TYPE_EXTENSION ||\n    def.kind === Kind.ENUM_TYPE_EXTENSION ||\n    def.kind === Kind.SCALAR_TYPE_EXTENSION ||\n    def.kind === Kind.SCHEMA_EXTENSION;\nexport function filterAndExtractExtensionDefinitions(ast) {\n    const extensionDefs = [];\n    const typesDefs = [];\n    ast.definitions.forEach(def => {\n        if (isExtensionNode(def)) {\n            extensionDefs.push(def);\n        }\n        else {\n            typesDefs.push(def);\n        }\n    });\n    return {\n        typesAst: {\n            ...ast,\n            definitions: typesDefs,\n        },\n        extensionsAst: {\n            ...ast,\n            definitions: extensionDefs,\n        },\n    };\n}\nexport function filterExtensionDefinitions(ast) {\n    const { typesAst } = filterAndExtractExtensionDefinitions(ast);\n    return typesAst;\n}\nexport function extractExtensionDefinitions(ast) {\n    const { extensionsAst } = filterAndExtractExtensionDefinitions(ast);\n    return extensionsAst;\n}\n//# sourceMappingURL=extensionDefinitions.js.map","import { print } from 'graphql';\nexport function concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs = new Set()) {\n    const resolvedTypeDefinitions = new Set();\n    typeDefinitionsAry.forEach((typeDef) => {\n        if (typeof typeDef === 'function') {\n            if (!calledFunctionRefs.has(typeDef)) {\n                calledFunctionRefs.add(typeDef);\n                resolvedTypeDefinitions.add(concatenateTypeDefs(typeDef(), calledFunctionRefs));\n            }\n        }\n        else if (typeof typeDef === 'string') {\n            resolvedTypeDefinitions.add(typeDef.trim());\n        }\n        else if (typeDef.kind !== undefined) {\n            resolvedTypeDefinitions.add(print(typeDef).trim());\n        }\n        else {\n            const type = typeof typeDef;\n            throw new Error(`typeDef array must contain only strings, documents, or functions, got ${type}`);\n        }\n    });\n    return [...resolvedTypeDefinitions].join('\\n');\n}\n//# sourceMappingURL=concatenateTypeDefs.js.map","import { extendSchema, buildASTSchema } from 'graphql';\nimport { parseGraphQLSDL, isDocumentNode } from '@graphql-tools/utils';\nimport { filterAndExtractExtensionDefinitions } from './extensionDefinitions';\nimport { concatenateTypeDefs } from './concatenateTypeDefs';\nexport function buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions, noExtensionExtraction) {\n    const document = buildDocumentFromTypeDefinitions(typeDefinitions, parseOptions);\n    if (noExtensionExtraction) {\n        return buildASTSchema(document);\n    }\n    const { typesAst, extensionsAst } = filterAndExtractExtensionDefinitions(document);\n    const backcompatOptions = { commentDescriptions: true };\n    let schema = buildASTSchema(typesAst, backcompatOptions);\n    if (extensionsAst.definitions.length > 0) {\n        schema = extendSchema(schema, extensionsAst, backcompatOptions);\n    }\n    return schema;\n}\nexport function buildDocumentFromTypeDefinitions(typeDefinitions, parseOptions) {\n    let document;\n    if (typeof typeDefinitions === 'string') {\n        document = parseGraphQLSDL('', typeDefinitions, parseOptions).document;\n    }\n    else if (Array.isArray(typeDefinitions)) {\n        document = parseGraphQLSDL('', concatenateTypeDefs(typeDefinitions), parseOptions).document;\n    }\n    else if (isDocumentNode(typeDefinitions)) {\n        document = typeDefinitions;\n    }\n    else {\n        const type = typeof typeDefinitions;\n        throw new Error(`typeDefs must be a string, array or schema AST, got ${type}`);\n    }\n    return document;\n}\n//# sourceMappingURL=buildSchemaFromTypeDefinitions.js.map","import { defaultFieldResolver } from 'graphql';\nexport function chainResolvers(resolvers) {\n    return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {\n        if (curResolver != null) {\n            return curResolver(prev, args, ctx, info);\n        }\n        return defaultFieldResolver(prev, args, ctx, info);\n    }, root);\n}\n//# sourceMappingURL=chainResolvers.js.map","import { defaultFieldResolver } from 'graphql';\n/*\n * fn: The function to decorate with the logger\n * logger: an object instance of type Logger\n * hint: an optional hint to add to the error's message\n */\nexport function decorateWithLogger(fn, logger, hint) {\n    const resolver = fn != null ? fn : defaultFieldResolver;\n    const logError = (e) => {\n        // TODO: clone the error properly\n        const newE = new Error();\n        newE.stack = e.stack;\n        /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n        if (hint) {\n            newE['originalMessage'] = e.message;\n            newE.message = `Error in resolver ${hint}\\n${e.message}`;\n        }\n        logger.log(newE);\n    };\n    return (root, args, ctx, info) => {\n        try {\n            const result = resolver(root, args, ctx, info);\n            // If the resolver returns a Promise log any Promise rejects.\n            if (result && typeof result.then === 'function' && typeof result.catch === 'function') {\n                result.catch((reason) => {\n                    // make sure that it's an error we're logging.\n                    const error = reason instanceof Error ? reason : new Error(reason);\n                    logError(error);\n                    // We don't want to leave an unhandled exception so pass on error.\n                    return reason;\n                });\n            }\n            return result;\n        }\n        catch (e) {\n            logError(e);\n            // we want to pass on the error, just in case.\n            throw e;\n        }\n    };\n}\n//# sourceMappingURL=decorateWithLogger.js.map","import { MapperKind, mapSchema } from '@graphql-tools/utils';\n// If we have any union or interface types throw if no there is no resolveType resolver\nexport function checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n    mapSchema(schema, {\n        [MapperKind.ABSTRACT_TYPE]: type => {\n            if (!type.resolveType) {\n                const message = `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass 'ignore' into ` +\n                    '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.';\n                if (requireResolversForResolveType === 'error') {\n                    throw new Error(message);\n                }\n                if (requireResolversForResolveType === 'warn') {\n                    // eslint-disable-next-line no-console\n                    console.warn(message);\n                }\n            }\n            return undefined;\n        },\n    });\n}\n//# sourceMappingURL=checkForResolveTypeResolver.js.map","export function extendResolversFromInterfaces(schema, resolvers) {\n    const typeNames = Object.keys({\n        ...schema.getTypeMap(),\n        ...resolvers,\n    });\n    const extendedResolvers = {};\n    typeNames.forEach(typeName => {\n        const type = schema.getType(typeName);\n        if (type && 'getInterfaces' in type) {\n            const allInterfaceResolvers = type\n                .getInterfaces()\n                .map(iFace => resolvers[iFace.name])\n                .filter(interfaceResolvers => interfaceResolvers != null);\n            extendedResolvers[typeName] = {};\n            allInterfaceResolvers.forEach(interfaceResolvers => {\n                Object.keys(interfaceResolvers).forEach(fieldName => {\n                    if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n                        extendedResolvers[typeName][fieldName] = interfaceResolvers[fieldName];\n                    }\n                });\n            });\n            const typeResolvers = resolvers[typeName];\n            extendedResolvers[typeName] = {\n                ...extendedResolvers[typeName],\n                ...typeResolvers,\n            };\n        }\n        else {\n            const typeResolvers = resolvers[typeName];\n            if (typeResolvers != null) {\n                extendedResolvers[typeName] = typeResolvers;\n            }\n        }\n    });\n    return extendedResolvers;\n}\n//# sourceMappingURL=extendResolversFromInterfaces.js.map","import { GraphQLEnumType, isSchema, GraphQLScalarType, GraphQLUnionType, GraphQLInterfaceType, GraphQLObjectType, isSpecifiedScalarType, isScalarType, isEnumType, isUnionType, isInterfaceType, isObjectType, } from 'graphql';\nimport { mapSchema, MapperKind, forEachDefaultValue, serializeInputValue, healSchema, parseInputValue, forEachField, } from '@graphql-tools/utils';\nimport { checkForResolveTypeResolver } from './checkForResolveTypeResolver';\nimport { extendResolversFromInterfaces } from './extendResolversFromInterfaces';\nexport function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n    const options = isSchema(schemaOrOptions)\n        ? {\n            schema: schemaOrOptions,\n            resolvers: legacyInputResolvers,\n            resolverValidationOptions: legacyInputValidationOptions,\n        }\n        : schemaOrOptions;\n    let { schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, } = options;\n    const { requireResolversToMatchSchema = 'error', requireResolversForResolveType } = resolverValidationOptions;\n    const resolvers = inheritResolversFromInterfaces\n        ? extendResolversFromInterfaces(schema, inputResolvers)\n        : inputResolvers;\n    Object.keys(resolvers).forEach(typeName => {\n        const resolverValue = resolvers[typeName];\n        const resolverType = typeof resolverValue;\n        if (typeName === '__schema') {\n            if (resolverType !== 'function') {\n                throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". A schema resolver's value must be of type object or function.`);\n            }\n        }\n        else {\n            if (resolverType !== 'object') {\n                throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n            }\n            const type = schema.getType(typeName);\n            if (type == null) {\n                if (requireResolversToMatchSchema === 'ignore') {\n                    return;\n                }\n                throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n            }\n            else if (isSpecifiedScalarType(type)) {\n                // allow -- without recommending -- overriding of specified scalar types\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        type[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else {\n                        type[fieldName] = resolverValue[fieldName];\n                    }\n                });\n            }\n            else if (isEnumType(type)) {\n                const values = type.getValues();\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (!fieldName.startsWith('__') &&\n                        !values.some(value => value.name === fieldName) &&\n                        requireResolversToMatchSchema &&\n                        requireResolversToMatchSchema !== 'ignore') {\n                        throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n                    }\n                });\n            }\n            else if (isUnionType(type)) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (!fieldName.startsWith('__') &&\n                        requireResolversToMatchSchema &&\n                        requireResolversToMatchSchema !== 'ignore') {\n                        throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n                    }\n                });\n            }\n            else if (isObjectType(type) || isInterfaceType(type)) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (!fieldName.startsWith('__')) {\n                        const fields = type.getFields();\n                        const field = fields[fieldName];\n                        if (field == null && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n                            throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n                        }\n                        const fieldResolve = resolverValue[fieldName];\n                        if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n                        }\n                    }\n                });\n            }\n        }\n    });\n    schema = updateResolversInPlace\n        ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver)\n        : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n    if (requireResolversForResolveType || requireResolversForResolveType !== 'ignore') {\n        checkForResolveTypeResolver(schema, requireResolversForResolveType);\n    }\n    return schema;\n}\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n    const typeMap = schema.getTypeMap();\n    Object.keys(resolvers).forEach(typeName => {\n        if (typeName !== '__schema') {\n            const type = schema.getType(typeName);\n            const resolverValue = resolvers[typeName];\n            if (isScalarType(type)) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n                    if (fieldName.startsWith('__')) {\n                        type[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && type.astNode != null) {\n                        type.astNode = {\n                            ...type.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.astNode.description,\n                            directives: ((_d = type.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n                        type.extensionASTNodes = ((_h = []) !== null && _h !== void 0 ? _h : type.extensionASTNodes).concat((_k = (_j = resolverValue) === null || _j === void 0 ? void 0 : _j.extensionASTNodes) !== null && _k !== void 0 ? _k : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        type.extensions != null &&\n                        resolverValue.extensions != null) {\n                        type.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n                    }\n                    else {\n                        type[fieldName] = resolverValue[fieldName];\n                    }\n                });\n            }\n            else if (isEnumType(type)) {\n                const config = type.toConfig();\n                const enumValueConfigMap = config.values;\n                Object.keys(resolverValue).forEach(fieldName => {\n                    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n                            directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        type.extensions != null &&\n                        resolverValue.extensions != null) {\n                        type.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n                    }\n                    else if (enumValueConfigMap[fieldName]) {\n                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                    }\n                });\n                typeMap[typeName] = new GraphQLEnumType(config);\n            }\n            else if (isUnionType(type)) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        type[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                });\n            }\n            else if (isObjectType(type) || isInterfaceType(type)) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        // this is for isTypeOf and resolveType and all the other stuff.\n                        type[fieldName.substring(2)] = resolverValue[fieldName];\n                        return;\n                    }\n                    const fields = type.getFields();\n                    const field = fields[fieldName];\n                    if (field != null) {\n                        const fieldResolve = resolverValue[fieldName];\n                        if (typeof fieldResolve === 'function') {\n                            // for convenience. Allows shorter syntax in resolver definition file\n                            field.resolve = fieldResolve;\n                        }\n                        else {\n                            setFieldProperties(field, fieldResolve);\n                        }\n                    }\n                });\n            }\n        }\n    });\n    // serialize all default values prior to healing fields with new scalar/enum types.\n    forEachDefaultValue(schema, serializeInputValue);\n    // schema may have new scalar/enum types that require healing\n    healSchema(schema);\n    // reparse all default values with new parsing functions.\n    forEachDefaultValue(schema, parseInputValue);\n    if (defaultFieldResolver != null) {\n        forEachField(schema, field => {\n            if (!field.resolve) {\n                field.resolve = defaultFieldResolver;\n            }\n        });\n    }\n    return schema;\n}\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n    schema = mapSchema(schema, {\n        [MapperKind.SCALAR_TYPE]: type => {\n            const config = type.toConfig();\n            const resolverValue = resolvers[type.name];\n            if (!isSpecifiedScalarType(type) && resolverValue != null) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n                            directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n                    }\n                    else {\n                        config[fieldName] = resolverValue[fieldName];\n                    }\n                });\n                return new GraphQLScalarType(config);\n            }\n        },\n        [MapperKind.ENUM_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            if (resolverValue != null) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n                            directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n                    }\n                    else if (enumValueConfigMap[fieldName]) {\n                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                    }\n                });\n                return new GraphQLEnumType(config);\n            }\n        },\n        [MapperKind.UNION_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                });\n                return new GraphQLUnionType(config);\n            }\n        },\n        [MapperKind.OBJECT_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                });\n                return new GraphQLObjectType(config);\n            }\n        },\n        [MapperKind.INTERFACE_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                });\n                return new GraphQLInterfaceType(config);\n            }\n        },\n        [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n            const resolverValue = resolvers[typeName];\n            if (resolverValue != null) {\n                const fieldResolve = resolverValue[fieldName];\n                if (fieldResolve != null) {\n                    const newFieldConfig = { ...fieldConfig };\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        newFieldConfig.resolve = fieldResolve;\n                    }\n                    else {\n                        setFieldProperties(newFieldConfig, fieldResolve);\n                    }\n                    return newFieldConfig;\n                }\n            }\n        },\n    });\n    if (defaultFieldResolver != null) {\n        schema = mapSchema(schema, {\n            [MapperKind.OBJECT_FIELD]: fieldConfig => ({\n                ...fieldConfig,\n                resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver,\n            }),\n        });\n    }\n    return schema;\n}\nfunction setFieldProperties(field, propertiesObj) {\n    Object.keys(propertiesObj).forEach(propertyName => {\n        field[propertyName] = propertiesObj[propertyName];\n    });\n}\n//# sourceMappingURL=addResolversToSchema.js.map","import { mapSchema, MapperKind } from '@graphql-tools/utils';\nimport { decorateWithLogger } from './decorateWithLogger';\nexport function addErrorLoggingToSchema(schema, logger) {\n    if (!logger) {\n        throw new Error('Must provide a logger');\n    }\n    if (typeof logger.log !== 'function') {\n        throw new Error('Logger.log must be a function');\n    }\n    return mapSchema(schema, {\n        [MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName) => ({\n            ...fieldConfig,\n            resolve: decorateWithLogger(fieldConfig.resolve, logger, `${typeName}.${fieldName}`),\n        }),\n    });\n}\n//# sourceMappingURL=addErrorLoggingToSchema.js.map","import { defaultFieldResolver } from 'graphql';\nimport { mapSchema, MapperKind } from '@graphql-tools/utils';\nfunction decorateToCatchUndefined(fn, hint) {\n    const resolve = fn == null ? defaultFieldResolver : fn;\n    return (root, args, ctx, info) => {\n        const result = resolve(root, args, ctx, info);\n        if (typeof result === 'undefined') {\n            throw new Error(`Resolver for \"${hint}\" returned undefined`);\n        }\n        return result;\n    };\n}\nexport function addCatchUndefinedToSchema(schema) {\n    return mapSchema(schema, {\n        [MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName) => ({\n            ...fieldConfig,\n            resolve: decorateToCatchUndefined(fieldConfig.resolve, `${typeName}.${fieldName}`),\n        }),\n    });\n}\n//# sourceMappingURL=addCatchUndefinedToSchema.js.map","import { mergeDeep, SchemaDirectiveVisitor, pruneSchema } from '@graphql-tools/utils';\nimport { addResolversToSchema } from './addResolversToSchema';\nimport { attachDirectiveResolvers } from './attachDirectiveResolvers';\nimport { assertResolversPresent } from './assertResolversPresent';\nimport { addSchemaLevelResolver } from './addSchemaLevelResolver';\nimport { buildSchemaFromTypeDefinitions } from './buildSchemaFromTypeDefinitions';\nimport { addErrorLoggingToSchema } from './addErrorLoggingToSchema';\nimport { addCatchUndefinedToSchema } from './addCatchUndefinedToSchema';\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additional syntax highlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nexport function makeExecutableSchema({ typeDefs, resolvers = {}, logger, allowUndefinedInResolve = true, resolverValidationOptions = {}, directiveResolvers, schemaDirectives, schemaTransforms: userProvidedSchemaTransforms, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, noExtensionExtraction = false, }) {\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new Error('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new Error('Must provide typeDefs');\n    }\n    // Arguments are now validated and cleaned up\n    const schemaTransforms = [\n        schema => {\n            // We allow passing in an array of resolver maps, in which case we merge them\n            const resolverMap = Array.isArray(resolvers) ? resolvers.reduce(mergeDeep, {}) : resolvers;\n            const schemaWithResolvers = addResolversToSchema({\n                schema,\n                resolvers: resolverMap,\n                resolverValidationOptions,\n                inheritResolversFromInterfaces,\n                updateResolversInPlace,\n            });\n            if (Object.keys(resolverValidationOptions).length > 0) {\n                assertResolversPresent(schemaWithResolvers, resolverValidationOptions);\n            }\n            return schemaWithResolvers;\n        },\n    ];\n    if (!allowUndefinedInResolve) {\n        schemaTransforms.push(addCatchUndefinedToSchema);\n    }\n    if (logger != null) {\n        schemaTransforms.push(schema => addErrorLoggingToSchema(schema, logger));\n    }\n    if (typeof resolvers['__schema'] === 'function') {\n        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n        // not doing that now, because I'd have to rewrite a lot of tests.\n        schemaTransforms.push(schema => addSchemaLevelResolver(schema, resolvers['__schema']));\n    }\n    if (userProvidedSchemaTransforms) {\n        schemaTransforms.push(schema => userProvidedSchemaTransforms.reduce((s, schemaTransform) => schemaTransform(s), schema));\n    }\n    // directive resolvers are implemented using SchemaDirectiveVisitor.visitSchemaDirectives\n    // schema visiting modifies the schema in place\n    if (directiveResolvers != null) {\n        schemaTransforms.push(schema => attachDirectiveResolvers(schema, directiveResolvers));\n    }\n    if (schemaDirectives != null) {\n        schemaTransforms.push(schema => {\n            SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n            return schema;\n        });\n    }\n    if (pruningOptions) {\n        schemaTransforms.push(pruneSchema);\n    }\n    const schemaFromTypeDefs = buildSchemaFromTypeDefinitions(typeDefs, parseOptions, noExtensionExtraction);\n    return schemaTransforms.reduce((schema, schemaTransform) => schemaTransform(schema), schemaFromTypeDefs);\n}\n//# sourceMappingURL=makeExecutableSchema.js.map"],"names":["mapSchema","MapperKind","ValueOrPromise","defaultFieldResolver","forEachField","isScalarType","getNamedType","getDirectives","Kind","print","buildASTSchema","extendSchema","parseGraphQLSDL","isDocumentNode","isSchema","isSpecifiedScalarType","isEnumType","isUnionType","isObjectType","isInterfaceType","GraphQLEnumType","forEachDefaultValue","serializeInputValue","healSchema","parseInputValue","GraphQLScalarType","GraphQLUnionType","GraphQLObjectType","GraphQLInterfaceType","mergeDeep","SchemaDirectiveVisitor","pruneSchema"],"mappings":"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"}