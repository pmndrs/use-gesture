{"version":3,"sources":["../../../src/schema/infer/type-conflict-reporter.ts"],"names":["formatValue","value","Array","isArray","util","inspect","colors","depth","breakLength","Infinity","output","length","push","wasElipsisLast","usedTypes","forEach","item","type","includes","join","TypeConflictEntry","constructor","selector","types","Map","addExample","parent","set","description","internal","printEntry","sortedByTypeName","from","entries","typeName","report","log","map","TypeConflictReporter","clearConflicts","clear","getEntryFromSelector","dataEntry","get","addConflict","examples","substring","entry","filter","example","printConflicts","size","warn","getConflicts","values"],"mappings":"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","sourcesContent":["import sortBy from \"lodash/sortBy\"\nimport report from \"gatsby-cli/lib/reporter\"\nimport typeOf from \"type-of\"\nimport util from \"util\"\n\nimport { Node } from \"../../../index\"\n\nexport interface ITypeConflictExample {\n  value: unknown\n  type: string\n  parent?: Node\n  arrayTypes?: Array<string>\n}\n\ninterface ITypeConflict {\n  value: unknown\n  description?: string\n}\n\nconst formatValue = (value: unknown): string => {\n  if (!Array.isArray(value)) {\n    return util.inspect(value, {\n      colors: true,\n      depth: 0,\n      breakLength: Infinity,\n    })\n  }\n\n  const output: Array<string> = []\n\n  if (value.length === 1) {\n    // For arrays usually a single conflicting item is exposed vs. the whole array\n    output.push(`...`)\n    output.push(formatValue(value[0]))\n    output.push(`...`)\n  } else {\n    let wasElipsisLast = false\n    const usedTypes: Array<string> = []\n    value.forEach(item => {\n      const type = typeOf(item)\n      if (usedTypes.includes(type)) {\n        if (!wasElipsisLast) {\n          output.push(`...`)\n          wasElipsisLast = true\n        }\n      } else {\n        output.push(formatValue(item))\n        wasElipsisLast = false\n        usedTypes.push(type)\n      }\n    })\n  }\n\n  return `[ ${output.join(`, `)} ]`\n}\n\nclass TypeConflictEntry {\n  selector: string\n  types: Map<string, ITypeConflict>\n\n  constructor(selector: string) {\n    this.selector = selector\n    this.types = new Map()\n  }\n\n  addExample({ value, type, parent }: ITypeConflictExample): void {\n    this.types.set(type, {\n      value,\n      description: parent?.internal?.description ?? ``,\n    })\n  }\n\n  printEntry(): void {\n    const sortedByTypeName = sortBy(\n      Array.from(this.types.entries()),\n      ([typeName]) => typeName\n    )\n\n    report.log(\n      `${this.selector}:${sortedByTypeName\n        .map(\n          ([typeName, { value, description }]) =>\n            `\\n - type: ${typeName}\\n   value: ${formatValue(value)}${\n              description && `\\n   source: ${description}`\n            }`\n        )\n        .join(``)}`\n    )\n  }\n}\n\nclass TypeConflictReporter {\n  entries: Map<string, TypeConflictEntry>\n\n  constructor() {\n    this.entries = new Map()\n  }\n\n  clearConflicts(): void {\n    this.entries.clear()\n  }\n\n  getEntryFromSelector(selector: string): TypeConflictEntry {\n    let dataEntry = this.entries.get(selector)\n\n    if (!dataEntry) {\n      dataEntry = new TypeConflictEntry(selector)\n      this.entries.set(selector, dataEntry)\n    }\n\n    return dataEntry\n  }\n\n  addConflict(selector: string, examples: Array<ITypeConflictExample>): void {\n    if (selector.substring(0, 11) === `SitePlugin.`) {\n      // Don't store and print out type conflicts in plugins.\n      // This is out of user control so he/she can't do anything\n      // to hide those.\n      return\n    }\n\n    const entry = this.getEntryFromSelector(selector)\n    examples\n      .filter(example => example.value != null)\n      .forEach(example => entry.addExample(example))\n  }\n\n  printConflicts(): void {\n    if (this.entries.size > 0) {\n      report.warn(\n        `There are conflicting field types in your data.\\n\\n` +\n          `If you have explicitly defined a type for those fields, you can ` +\n          `safely ignore this warning message.\\n` +\n          `Otherwise, Gatsby will omit those fields from the GraphQL schema.\\n\\n` +\n          `If you know all field types in advance, the best strategy is to ` +\n          `explicitly define them with the \\`createTypes\\` action, and skip ` +\n          `inference with the \\`@dontInfer\\` directive.\\n` +\n          `See https://www.gatsbyjs.org/docs/actions/#createTypes`\n      )\n      this.entries.forEach(entry => entry.printEntry())\n    }\n  }\n\n  getConflicts(): Array<TypeConflictEntry> {\n    return Array.from(this.entries.values())\n  }\n}\n\nexport { TypeConflictReporter, TypeConflictEntry }\n"],"file":"type-conflict-reporter.js"}