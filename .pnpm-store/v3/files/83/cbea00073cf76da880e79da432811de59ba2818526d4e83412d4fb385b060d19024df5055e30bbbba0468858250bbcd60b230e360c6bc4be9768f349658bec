{"version":3,"sources":["../../../src/utils/eslint-rules/limited-exports-page-templates.ts"],"names":["DEFAULT_GRAPHQL_TAG_NAME","hasOneValidNamedDeclaration","node","varName","type","declaration","nonQueryExports","specifiers","some","e","exported","name","isTemplateQuery","graphqlTagName","namespaceSpecifierName","declarations","every","el","init","tag","object","property","limitedExports","meta","messages","limitedExportsPageTemplates","create","context","store","queryVariableName","VariableDeclaration","requiredFromGatsby","find","arguments","quasis","value","raw","graphqlTagSpecifier","id","properties","key","undefined","ImportDeclaration","source","imported","local","TaggedTemplateExpression","parent","ExportNamedDeclaration","report","messageId","module","exports"],"mappings":"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","sourcesContent":["import { Rule } from \"eslint\"\nimport {\n  Node,\n  Identifier,\n  ImportDeclaration,\n  TaggedTemplateExpression,\n  VariableDeclaration,\n  CallExpression,\n  Literal,\n  TemplateLiteral,\n  VariableDeclarator,\n  ObjectPattern,\n  AssignmentProperty,\n} from \"estree\"\nimport { store } from \"../../redux\"\nimport { isPageTemplate } from \"../eslint-rules-helpers\"\n\nconst DEFAULT_GRAPHQL_TAG_NAME = `graphql`\n\nfunction hasOneValidNamedDeclaration(\n  node: Node,\n  varName: string | undefined\n): boolean {\n  // Checks for:\n  // const query = graphql``\n  // export { query }\n  if (\n    node.type === `ExportNamedDeclaration` &&\n    node.declaration === null &&\n    varName\n  ) {\n    // For export { foobar, query } the declaration will be null and specifiers exists\n    // For { foobar, query } it'll return true, for { query } it'll return false\n    const nonQueryExports = node.specifiers.some(\n      e => e.exported.name !== varName\n    )\n    return !nonQueryExports\n  }\n\n  return false\n}\n\nfunction isTemplateQuery(\n  node: Node,\n  graphqlTagName: string,\n  namespaceSpecifierName: string\n): boolean {\n  // For export const query = 'foobar' the declaration exists with type 'VariableDeclaration'\n\n  // Checks for:\n  // export const query = graphql``\n  // This case only has one item in the declarations array\n  // For export const hello = 10, world = 'foo'\n  // The array will have two items. So use every() to check if only one item exists\n  // With TaggedTemplateExpression and \"graphql\" name\n\n  // In addition the declaration can also be a MemberExpression like\n  // Gatsby.graphql`` when the import happened with import * as Gatsby from \"gatsby\"\n\n  return (\n    node.type === `ExportNamedDeclaration` &&\n    node.declaration?.type === `VariableDeclaration` &&\n    node.declaration?.declarations.every(el => {\n      if (\n        el?.init?.type === `TaggedTemplateExpression` &&\n        el.init.tag.type === `Identifier`\n      ) {\n        return el.init.tag.name === graphqlTagName\n      } else if (\n        el?.init?.type === `TaggedTemplateExpression` &&\n        el.init.tag.type === `MemberExpression`\n      ) {\n        return (\n          (el.init.tag.object as Identifier).name === namespaceSpecifierName &&\n          (el.init.tag.property as Identifier).name === DEFAULT_GRAPHQL_TAG_NAME\n        )\n      }\n      return false\n    })\n  )\n}\n\nconst limitedExports: Rule.RuleModule = {\n  meta: {\n    type: `problem`,\n    messages: {\n      limitedExportsPageTemplates: `In page templates only a default export of a valid React component and the named export of a page query is allowed.\n        All other named exports will cause Fast Refresh to not preserve local component state and do a full refresh.\n\n        Please move your other named exports to another file. Also make sure that you only export page queries that use the \"graphql\" tag from \"gatsby\".\n`,\n    },\n  },\n  create: context => {\n    if (!isPageTemplate(store, context)) {\n      return {}\n    }\n\n    let queryVariableName: string | undefined = ``\n    let graphqlTagName = ``\n    let namespaceSpecifierName = ``\n\n    return {\n      // const { graphql } = require('gatsby')\n      VariableDeclaration: (node): void => {\n        // Check if require('gatsby')\n        const requiredFromGatsby = (\n          node as VariableDeclaration\n        ).declarations.find(el => {\n          // Handle require(`gatsby`)\n          if (\n            (el.init as CallExpression)?.arguments?.[0]?.type ===\n            `TemplateLiteral`\n          ) {\n            return (\n              ((el.init as CallExpression).arguments[0] as TemplateLiteral)\n                ?.quasis[0].value.raw === `gatsby`\n            )\n          }\n\n          return (\n            ((el.init as CallExpression)?.arguments?.[0] as Literal)?.value ===\n            `gatsby`\n          )\n        })\n\n        if (requiredFromGatsby) {\n          // Search for \"graphql\" in a const { graphql, Link } = require('gatsby')\n          const graphqlTagSpecifier = (\n            (requiredFromGatsby as VariableDeclarator).id as ObjectPattern\n          )?.properties.find(\n            el =>\n              ((el as AssignmentProperty).key as Identifier).name ===\n              DEFAULT_GRAPHQL_TAG_NAME\n          )\n\n          if (graphqlTagSpecifier) {\n            graphqlTagName = (\n              (graphqlTagSpecifier as AssignmentProperty).value as Identifier\n            ).name\n          }\n        }\n\n        return undefined\n      },\n      // import { graphql } from \"gatsby\"\n      ImportDeclaration: (node): void => {\n        // Make sure that the specifier is imported from \"gatsby\"\n        if ((node as ImportDeclaration).source.value === `gatsby`) {\n          const graphqlTagSpecifier = (\n            node as ImportDeclaration\n          ).specifiers.find(el => {\n            // We only want import { graphql } from \"gatsby\"\n            // Not import graphql from \"gatsby\"\n            if (el.type === `ImportSpecifier`) {\n              // Only get the specifier with the original name of \"graphql\"\n              return el.imported.name === DEFAULT_GRAPHQL_TAG_NAME\n            }\n            // import * as Gatsby from \"gatsby\"\n            if (el.type === `ImportNamespaceSpecifier`) {\n              namespaceSpecifierName = el.local.name\n              return false\n            }\n            return false\n          })\n          if (graphqlTagSpecifier) {\n            // The local.name handles the case for import { graphql as otherName }\n            // For normal import { graphql } the imported & local name are the same\n            graphqlTagName = graphqlTagSpecifier.local.name\n          }\n        }\n        return undefined\n      },\n      TaggedTemplateExpression: (node): void => {\n        if (\n          (node as TaggedTemplateExpression).type ===\n            `TaggedTemplateExpression` &&\n          ((node as TaggedTemplateExpression).tag as Identifier)?.name ===\n            graphqlTagName\n        ) {\n          if (queryVariableName) {\n            return undefined\n          }\n          // @ts-ignore\n          queryVariableName = node.parent?.id?.name\n        }\n\n        return undefined\n      },\n      ExportNamedDeclaration: (node): void => {\n        if (hasOneValidNamedDeclaration(node, queryVariableName)) {\n          return undefined\n        }\n\n        if (isTemplateQuery(node, graphqlTagName, namespaceSpecifierName)) {\n          return undefined\n        }\n\n        context.report({\n          node,\n          messageId: `limitedExportsPageTemplates`,\n        })\n\n        return undefined\n      },\n    }\n  },\n}\n\nmodule.exports = limitedExports\n"],"file":"limited-exports-page-templates.js"}