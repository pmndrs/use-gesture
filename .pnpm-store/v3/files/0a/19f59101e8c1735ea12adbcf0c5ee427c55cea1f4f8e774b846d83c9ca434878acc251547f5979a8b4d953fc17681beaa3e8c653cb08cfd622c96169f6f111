{"version":3,"sources":["../../../../src/datastore/lmdb/query/run-query.ts"],"names":["doRunQuery","args","context","createQueryContext","nodeId","getFilterById","node","datastore","getNode","entries","GatsbyIterable","totalCount","runCountOnce","limit","undefined","skip","canUseIndex","Promise","all","nodeTypeNames","map","typeName","suggestedIndexFields","performIndexScan","performFullTableScan","sortFields","filterContext","length","result","resultOffset","indexMetadata","needsSorting","nodes","usedSkip","filterNodes","concat","canUseIndexForSorting","mergeSorted","createNodeSortComparator","unlimited","sortedNodes","sortNodesInMemory","actualSkip","slice","runCount","count","needsFiltering","countNodes","completeFiltering","iterateNodesByType","_","e","usedQueries","reverse","Array","from","values","value","filter","Boolean","intermediateResult","Set","dbQueries","isFullyFiltered","resolvedNodes","store","getState","resolvedNodesCache","filtersToApply","q","has","resolvedFields","get","internal","type","id","dottedField","tmp","isArray","some","v","arr","sort","queryArgs","firstOnly","databases","Map","fields","field","i","order","size","index","indexKeyFields","keyFields","sortOrder","comparator","DbComparator","EQ","String","nodeComparator","a","b","resolvedAFields","resolvedBFields","direction","valueA","valueB","compareByKeySuffix","prefixLength","aSuffix","key","bSuffix"],"mappings":"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","sourcesContent":["import {\n  IDataStore,\n  ILmdbDatabases,\n  IQueryResult,\n  IRunQueryArgs,\n} from \"../../types\"\nimport { IGatsbyNode } from \"../../../redux/types\"\nimport { GatsbyIterable } from \"../../common/iterable\"\nimport {\n  createDbQueriesFromObject,\n  DbComparator,\n  DbQuery,\n  dbQueryToDottedField,\n  getFilterStatement,\n  IDbFilterStatement,\n  prepareQueryArgs,\n} from \"../../common/query\"\nimport {\n  createIndex,\n  getIndexMetadata,\n  IIndexMetadata,\n  IndexFields,\n} from \"./create-index\"\nimport {\n  countUsingIndexOnly,\n  filterUsingIndex,\n  IIndexEntry,\n} from \"./filter-using-index\"\nimport { store } from \"../../../redux\"\nimport { isDesc, resolveFieldValue, matchesFilter, compareKey } from \"./common\"\nimport { suggestIndex } from \"./suggest-index\"\n\ninterface IDoRunQueryArgs extends IRunQueryArgs {\n  databases: ILmdbDatabases\n  datastore: IDataStore\n}\n\ntype SortFields = Map<string, number>\n\ninterface IQueryContext {\n  datastore: IDataStore\n  databases: ILmdbDatabases\n  dbQueries: Array<DbQuery>\n  sortFields: SortFields\n  nodeTypeNames: Array<string>\n  suggestedIndexFields: IndexFields\n  indexMetadata?: IIndexMetadata\n  limit?: number\n  skip: number\n  totalCount?: number\n}\n\nexport async function doRunQuery(args: IDoRunQueryArgs): Promise<IQueryResult> {\n  // Note: Keeping doRunQuery method the only async method in chain for perf\n  const context = createQueryContext(args)\n\n  // Fast-path: filter by node id\n  const nodeId = getFilterById(context)\n  if (nodeId) {\n    const node = args.datastore.getNode(nodeId)\n    return {\n      entries: new GatsbyIterable(node ? [node] : []),\n      totalCount: async (): Promise<number> => (node ? 1 : 0),\n    }\n  }\n\n  const totalCount = async (): Promise<number> =>\n    runCountOnce({ ...context, limit: undefined, skip: 0 })\n\n  if (canUseIndex(context)) {\n    await Promise.all(\n      context.nodeTypeNames.map(typeName =>\n        createIndex(context, typeName, context.suggestedIndexFields)\n      )\n    )\n    return { entries: performIndexScan(context), totalCount }\n  }\n  return { entries: performFullTableScan(context), totalCount }\n}\n\nfunction performIndexScan(context: IQueryContext): GatsbyIterable<IGatsbyNode> {\n  const { suggestedIndexFields, sortFields } = context\n\n  const filterContext =\n    context.nodeTypeNames.length === 1\n      ? context\n      : {\n          ...context,\n          skip: 0,\n          limit:\n            typeof context.limit === `undefined`\n              ? undefined\n              : context.skip + context.limit,\n        }\n\n  let result = new GatsbyIterable<IGatsbyNode>([])\n  let resultOffset = filterContext.skip\n  for (const typeName of context.nodeTypeNames) {\n    const indexMetadata = getIndexMetadata(\n      context,\n      typeName,\n      suggestedIndexFields\n    )\n    if (!needsSorting(context)) {\n      const { nodes, usedSkip } = filterNodes(filterContext, indexMetadata)\n      result = result.concat(nodes)\n      resultOffset = usedSkip\n      continue\n    }\n    if (canUseIndexForSorting(indexMetadata, sortFields)) {\n      const { nodes, usedSkip } = filterNodes(filterContext, indexMetadata)\n      // Interleave nodes of different types (not expensive for already sorted chunks)\n      result = result.mergeSorted(nodes, createNodeSortComparator(sortFields))\n      resultOffset = usedSkip\n      continue\n    }\n    // The sad part - unlimited filter + in-memory sort\n    const unlimited = { ...context, skip: 0, limit: undefined }\n    const { nodes, usedSkip } = filterNodes(unlimited, indexMetadata)\n    const sortedNodes = sortNodesInMemory(context, nodes)\n    resultOffset = usedSkip\n\n    result = result.mergeSorted(\n      sortedNodes,\n      createNodeSortComparator(sortFields)\n    )\n  }\n  const { limit, skip = 0 } = context\n  const actualSkip = skip - resultOffset\n\n  if (limit || actualSkip) {\n    result = result.slice(actualSkip, limit ? actualSkip + limit : undefined)\n  }\n  return result\n}\n\nfunction runCountOnce(context: IQueryContext): number {\n  if (typeof context.totalCount === `undefined`) {\n    context.totalCount = runCount(context)\n  }\n  return context.totalCount\n}\n\nfunction runCount(context: IQueryContext): number {\n  let count = 0\n\n  if (!needsFiltering(context)) {\n    for (const typeName of context.nodeTypeNames) {\n      count += context.datastore.countNodes(typeName)\n    }\n    return count\n  }\n\n  if (!canUseIndex(context)) {\n    for (const typeName of context.nodeTypeNames) {\n      const nodes = completeFiltering(\n        context,\n        new GatsbyIterable(context.datastore.iterateNodesByType(typeName))\n      )\n      for (const _ of nodes) count++\n    }\n    return count\n  }\n\n  for (const typeName of context.nodeTypeNames) {\n    const indexMetadata = getIndexMetadata(\n      context,\n      typeName,\n      context.suggestedIndexFields\n    )\n    try {\n      count += countUsingIndexOnly({ ...context, indexMetadata })\n    } catch (e) {\n      // We cannot reliably count using index - fallback to full iteration :/\n      for (const _ of filterNodes(context, indexMetadata).nodes) count++\n    }\n  }\n  return count\n}\n\nfunction performFullTableScan(\n  context: IQueryContext\n): GatsbyIterable<IGatsbyNode> {\n  // console.warn(`Fallback to full table scan :/`)\n\n  const { datastore, nodeTypeNames } = context\n\n  let result = new GatsbyIterable<IGatsbyNode>([])\n  for (const typeName of nodeTypeNames) {\n    let nodes = new GatsbyIterable(datastore.iterateNodesByType(typeName))\n    nodes = completeFiltering(context, nodes)\n\n    if (needsSorting(context)) {\n      nodes = sortNodesInMemory(context, nodes)\n      result = result.mergeSorted(\n        nodes,\n        createNodeSortComparator(context.sortFields)\n      )\n    } else {\n      result = result.concat(nodes)\n    }\n  }\n  const { limit, skip = 0 } = context\n\n  if (limit || skip) {\n    result = result.slice(skip, limit ? skip + limit : undefined)\n  }\n  return result\n}\n\nfunction filterNodes(\n  context: IQueryContext,\n  indexMetadata: IIndexMetadata\n): { nodes: GatsbyIterable<IGatsbyNode>; usedSkip: number } {\n  const { entries, usedQueries, usedSkip } = filterUsingIndex({\n    ...context,\n    indexMetadata,\n    reverse: Array.from(context.sortFields.values())[0] === -1,\n  })\n  const nodes = entries\n    .map(({ value }) => context.datastore.getNode(value))\n    .filter(Boolean)\n\n  return {\n    nodes: completeFiltering(\n      context,\n      nodes as GatsbyIterable<IGatsbyNode>,\n      usedQueries\n    ),\n    usedSkip,\n  }\n}\n\n/**\n * Takes intermediate result and applies any remaining filterQueries.\n *\n * If result is already fully filtered - simply returns.\n */\nfunction completeFiltering(\n  context: IQueryContext,\n  intermediateResult: GatsbyIterable<IGatsbyNode>,\n  usedQueries: Set<DbQuery> = new Set()\n): GatsbyIterable<IGatsbyNode> {\n  const { dbQueries } = context\n  if (isFullyFiltered(dbQueries, usedQueries)) {\n    return intermediateResult\n  }\n  // Apply remaining filter operations directly (last resort: slow)\n  const resolvedNodes = store.getState().resolvedNodesCache\n\n  const filtersToApply: Array<[string, IDbFilterStatement]> = dbQueries\n    .filter(q => !usedQueries.has(q))\n    .map(q => [dbQueryToDottedField(q), getFilterStatement(q)])\n\n  return intermediateResult.filter(node => {\n    const resolvedFields = resolvedNodes?.get(node.internal.type)?.get(node.id)\n\n    for (const [dottedField, filter] of filtersToApply) {\n      const tmp = resolveFieldValue(dottedField, node, resolvedFields)\n      const value = Array.isArray(tmp) ? tmp : [tmp]\n      if (value.some(v => !matchesFilter(filter, v))) {\n        // Mimic AND semantics\n        return false\n      }\n    }\n    return true\n  })\n}\n\nfunction sortNodesInMemory(\n  context: IQueryContext,\n  nodes: GatsbyIterable<IGatsbyNode>\n): GatsbyIterable<IGatsbyNode> {\n  // TODO: Sort using index data whenever possible (maybe store data needed for sorting in index values)\n  // TODO: Nodes can be partially sorted by index prefix - we can (and should) exploit this\n  return new GatsbyIterable(() => {\n    const arr = Array.from(nodes)\n    arr.sort(createNodeSortComparator(context.sortFields))\n    return arr\n  })\n}\n\nfunction createQueryContext(args: IDoRunQueryArgs): IQueryContext {\n  const { queryArgs: { filter, sort, limit, skip = 0 } = {}, firstOnly } = args\n\n  return {\n    datastore: args.datastore,\n    databases: args.databases,\n    nodeTypeNames: args.nodeTypeNames,\n    dbQueries: createDbQueriesFromObject(prepareQueryArgs(filter)),\n    sortFields: new Map<string, number>(\n      sort?.fields.map((field, i) => [field, isDesc(sort?.order[i]) ? -1 : 1])\n    ),\n    suggestedIndexFields: new Map(suggestIndex({ filter, sort })),\n    limit: firstOnly ? 1 : limit,\n    skip,\n  }\n}\n\nfunction canUseIndex(context: IQueryContext): boolean {\n  return context.suggestedIndexFields.size > 0\n}\n\nfunction needsFiltering(context: IQueryContext): boolean {\n  return context.dbQueries.length > 0\n}\n\nfunction needsSorting(context: IQueryContext): boolean {\n  return context.sortFields.size > 0\n}\n\n/**\n * Based on assumption that if all sort fields exist in index\n * then any result received from this index is fully sorted\n */\nfunction canUseIndexForSorting(\n  index: IIndexMetadata,\n  sortFields: SortFields\n): boolean {\n  const indexKeyFields = new Map(index.keyFields)\n  for (const [field, sortOrder] of sortFields) {\n    if (indexKeyFields.get(field) !== sortOrder) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isFullyFiltered(\n  dbQueries: Array<DbQuery>,\n  usedQueries: Set<DbQuery>\n): boolean {\n  return dbQueries.length === usedQueries.size\n}\n\nfunction getFilterById(context: IQueryContext): string | undefined {\n  for (const q of context.dbQueries) {\n    const filter = getFilterStatement(q)\n    if (\n      filter.comparator === DbComparator.EQ &&\n      dbQueryToDottedField(q) === `id`\n    ) {\n      return String(filter.value)\n    }\n  }\n  return undefined\n}\n\nfunction createNodeSortComparator(sortFields: SortFields): (a, b) => number {\n  const resolvedNodesCache = store.getState().resolvedNodesCache\n\n  return function nodeComparator(a: IGatsbyNode, b: IGatsbyNode): number {\n    const resolvedAFields = resolvedNodesCache?.get(a.internal.type)?.get(a.id)\n    const resolvedBFields = resolvedNodesCache?.get(b.internal.type)?.get(b.id)\n\n    for (const [field, direction] of sortFields) {\n      const valueA: any = resolveFieldValue(field, a, resolvedAFields)\n      const valueB: any = resolveFieldValue(field, b, resolvedBFields)\n\n      if (valueA > valueB) {\n        return direction === 1 ? 1 : -1\n      } else if (valueA < valueB) {\n        return direction === 1 ? -1 : 1\n      }\n    }\n    return 0\n  }\n}\n\nexport function compareByKeySuffix(prefixLength: number) {\n  return function (a: IIndexEntry, b: IIndexEntry): number {\n    const aSuffix = a.key.slice(prefixLength)\n    const bSuffix = b.key.slice(prefixLength)\n    // @ts-ignore\n    return compareKey(aSuffix, bSuffix)\n  }\n}\n"],"file":"run-query.js"}