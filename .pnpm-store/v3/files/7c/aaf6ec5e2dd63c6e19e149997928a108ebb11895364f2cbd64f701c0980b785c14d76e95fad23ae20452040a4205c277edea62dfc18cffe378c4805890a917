{"version":3,"sources":["../../../src/utils/dev-ssr/render-dev-html.ts"],"names":["startWorker","newWorker","WorkerPool","require","resolve","numWorkers","env","NODE_ENV","forceColors","GATSBY_EXPERIMENTAL_DEV_SSR","worker","initDevWorkerPool","changeCount","restartWorker","htmlComponentRendererPath","oldWorker","end","all","deleteModuleCache","searchFileForString","substring","filePath","Promise","escapedSubString","replace","chunkRegex","RegExp","stream","fs","createReadStream","found","on","d","test","toString","close","ensurePathComponentInSSRBundle","page","directory","report","panic","nodePath","join","componentChunkName","readAttempts","searchForStringInterval","setInterval","clearInterval","renderDevHTML","path","skipSsr","store","error","undefined","reject","pageObj","getState","isClientOnlyPage","matchPath","actions","createServerVisitedPage","dispatch","devssrWebpackCompiler","devssrWebpackWatcher","needToRecompileSSRBundle","isResolved","finish","stats","emitter","off","resume","suspend","setTimeout","publicDir","htmlString","single","renderHTML","componentPath","component"],"mappings":"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","sourcesContent":["import { WorkerPool } from \"gatsby-worker\"\nimport fs from \"fs-extra\"\nimport nodePath from \"path\"\nimport report from \"gatsby-cli/lib/reporter\"\nimport { isCI } from \"gatsby-core-utils\"\nimport { Stats } from \"webpack\"\nimport { startListener } from \"../../bootstrap/requires-writer\"\nimport { findPageByPath } from \"../find-page-by-path\"\nimport { getPageData as getPageDataExperimental } from \"../get-page-data\"\nimport { getDevSSRWebpack } from \"../../commands/build-html\"\nimport { emitter, GatsbyReduxStore } from \"../../redux\"\nimport { IGatsbyPage } from \"../../redux/types\"\n\ninterface IErrorRenderMeta {\n  codeFrame: string\n  source: string\n  line: number\n  column: number\n  sourceMessage?: string\n  stack?: string\n}\n\n// TODO: convert `render-dev-html-child.js` to TS and use `typeof import(\"./render-dev-html-child\")`\n// instead of defining interface here\ninterface IRenderDevHtmlChild {\n  renderHTML: (arg: {\n    path: string\n    componentPath: string\n    htmlComponentRendererPath: string\n    publicDir: string\n    isClientOnlyPage?: boolean\n    error?: IErrorRenderMeta\n    directory?: string\n  }) => Promise<string>\n  deleteModuleCache: (htmlComponentRendererPath: string) => void\n}\n\nconst startWorker = (): WorkerPool<IRenderDevHtmlChild> => {\n  const newWorker = new WorkerPool<IRenderDevHtmlChild>(\n    require.resolve(`./render-dev-html-child`),\n    {\n      numWorkers: 1,\n      env: {\n        NODE_ENV: isCI() ? `production` : `development`,\n        forceColors: `true`,\n        GATSBY_EXPERIMENTAL_DEV_SSR: `true`,\n      },\n    }\n  )\n\n  return newWorker\n}\n\nlet worker: WorkerPool<IRenderDevHtmlChild>\nexport const initDevWorkerPool = (): void => {\n  worker = startWorker()\n}\n\nlet changeCount = 0\nexport const restartWorker = (htmlComponentRendererPath: string): void => {\n  changeCount += 1\n  // Forking is expensive — each time we re-require the outputted webpack\n  // file, memory grows ~10 mb — 25 regenerations means ~250mb which seems\n  // like an acceptable amount of memory to grow before we reclaim it\n  // by rebooting the worker process.\n  if (changeCount > 25) {\n    const oldWorker = worker\n    const newWorker = startWorker()\n    worker = newWorker\n    oldWorker.end()\n    changeCount = 0\n  } else {\n    worker.all.deleteModuleCache(htmlComponentRendererPath)\n  }\n}\n\nconst searchFileForString = (\n  substring: string,\n  filePath: string\n): Promise<boolean> =>\n  new Promise(resolve => {\n    const escapedSubString = substring.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\n\n    // See if the chunk is in the newComponents array (not the notVisited).\n    const chunkRegex = RegExp(\n      `exports.ssrComponents.*${escapedSubString}.*}`,\n      `gs`\n    )\n    const stream = fs.createReadStream(filePath)\n    let found = false\n    stream.on(`data`, function (d) {\n      if (chunkRegex.test(d.toString())) {\n        found = true\n        stream.close()\n        resolve(found)\n      }\n    })\n    stream.on(`error`, function () {\n      resolve(found)\n    })\n    stream.on(`close`, function () {\n      resolve(found)\n    })\n  })\n\nconst ensurePathComponentInSSRBundle = async (\n  page,\n  directory\n): Promise<boolean> => {\n  // This shouldn't happen.\n  if (!page) {\n    report.panic(`page not found`, page)\n  }\n\n  // Now check if it's written to public/render-page.js\n  const htmlComponentRendererPath = nodePath.join(\n    directory,\n    `public/render-page.js`\n  )\n\n  // This search takes 1-10ms\n  // We do it as there can be a race conditions where two pages\n  // are requested at the same time which means that both are told render-page.js\n  // has changed when the first page is complete meaning the second\n  // page's component won't be in the render meaning its SSR will fail.\n  let found = await searchFileForString(\n    page.componentChunkName,\n    htmlComponentRendererPath\n  )\n\n  if (!found) {\n    await new Promise<void>(resolve => {\n      let readAttempts = 0\n      const searchForStringInterval = setInterval(async () => {\n        readAttempts += 1\n        found = await searchFileForString(\n          page.componentChunkName,\n          htmlComponentRendererPath\n        )\n        if (found || readAttempts > 5) {\n          clearInterval(searchForStringInterval)\n          resolve()\n        }\n      }, 300)\n    })\n  }\n\n  return found\n}\n\ninterface IRenderDevHtmlProps {\n  path: string\n  page: IGatsbyPage\n  skipSsr?: boolean\n  store: GatsbyReduxStore\n  error?: IErrorRenderMeta\n  htmlComponentRendererPath: string\n  directory: string\n}\n\nexport const renderDevHTML = ({\n  path,\n  page,\n  skipSsr = false,\n  store,\n  error = undefined,\n  htmlComponentRendererPath,\n  directory,\n}: IRenderDevHtmlProps): Promise<string> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    startListener()\n    let pageObj\n    if (!page) {\n      pageObj = findPageByPath(store.getState(), path)\n    } else {\n      pageObj = page\n    }\n\n    let isClientOnlyPage = false\n    if (pageObj.matchPath) {\n      isClientOnlyPage = true\n    }\n\n    const { actions } = require(`../../redux/actions`)\n    const { createServerVisitedPage } = actions\n    // Record this page was requested. This will kick off adding its page\n    // component to the ssr bundle (if that's not already happened)\n    store.dispatch(createServerVisitedPage(pageObj.componentChunkName))\n\n    // Ensure the query has been run and written out.\n    try {\n      await getPageDataExperimental(pageObj.path)\n    } catch {\n      // If we can't get the page, it was probably deleted recently\n      // so let's just do a 404 page.\n      return reject(`404 page`)\n    }\n\n    // Resume the webpack watcher and wait for any compilation necessary to happen.\n    // We timeout after 1.5s as the user might not care per se about SSR.\n    //\n    // We pause and resume so there's no excess webpack activity during normal development.\n    const {\n      devssrWebpackCompiler,\n      devssrWebpackWatcher,\n      needToRecompileSSRBundle,\n    } = getDevSSRWebpack()\n    if (\n      devssrWebpackWatcher &&\n      devssrWebpackCompiler &&\n      needToRecompileSSRBundle\n    ) {\n      let isResolved = false\n      await new Promise<Stats | void>(resolve => {\n        function finish(stats: Stats): void {\n          emitter.off(`DEV_SSR_COMPILATION_DONE`, finish)\n          if (!isResolved) {\n            resolve(stats)\n          }\n        }\n        emitter.on(`DEV_SSR_COMPILATION_DONE`, finish)\n        devssrWebpackWatcher.resume()\n        // Suspending is just a flag, so it's safe to re-suspend right away\n        devssrWebpackWatcher.suspend()\n\n        // Timeout after 1.5s.\n        setTimeout(() => {\n          isResolved = true\n          resolve()\n        }, 1500)\n      })\n    }\n\n    // Wait for public/render-page.js to update w/ the page component.\n    const found = await ensurePathComponentInSSRBundle(pageObj, directory)\n\n    // If we can't find the page, just force set isClientOnlyPage\n    // which skips rendering the body (so we just serve a shell)\n    // and the page will render normally on the client.\n    //\n    // This only happens on the first time we try to render a page component\n    // and it's taking a while to bundle its page component.\n    if (!found) {\n      isClientOnlyPage = true\n    }\n\n    // If the user added the query string `skip-ssr`, we always just render an empty shell.\n    if (skipSsr) {\n      isClientOnlyPage = true\n    }\n\n    const publicDir = nodePath.join(directory, `public`)\n\n    try {\n      const htmlString = await worker.single.renderHTML({\n        path,\n        componentPath: pageObj.component,\n        htmlComponentRendererPath,\n        directory,\n        publicDir,\n        isClientOnlyPage,\n        error,\n      })\n      return resolve(htmlString)\n    } catch (error) {\n      return reject(error)\n    }\n  })\n"],"file":"render-dev-html.js"}