{"version":3,"sources":["../../../src/utils/jobs/manager.ts"],"names":["activityForJobs","activeJobs","isListeningForMessages","hasShownIPCDisabledWarning","jobsInProcess","Map","externalJobsMap","convertPathsToAbsolute","filePath","path","isAbsolute","Error","createFileHash","hasha","fromFileSync","algorithm","hasActiveJobs","hasExternalJobsEnabled","process","env","ENABLE_GATSBY_EXTERNAL_JOBS","runLocalWorker","workerFn","job","fs","ensureDir","outputDir","Promise","resolve","reject","setImmediate","inputPaths","args","err","WorkerError","isJobsIPCMessage","msg","type","payload","id","has","listenForJobMessages","on","deferred","get","MESSAGE_TYPES","JOB_COMPLETED","result","JOB_FAILED","error","JOB_NOT_WHITELISTED","runJob","delete","runExternalWorker","set","jobCreatedMessage","JOB_CREATED","send","promise","forceLocal","plugin","worker","require","posix","join","name","isLocal","reporter","warn","version","isInternalJob","undefined","contentDigest","createInternalJob","inputPathsWithContentDigest","map","pth","internalJob","includes","inputPath","enqueueJob","phantomActivity","start","_","isPlainObject","end","getInProcessJobPromise","removeInProgressJob","waitUntilAllJobsComplete","isJobStale","areInputPathsStale","some","existsSync","fileHash"],"mappings":"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","sourcesContent":["import uuidv4 from \"uuid/v4\"\nimport path from \"path\"\nimport hasha from \"hasha\"\nimport fs from \"fs-extra\"\nimport pDefer from \"p-defer\"\nimport _ from \"lodash\"\nimport { createContentDigest, slash } from \"gatsby-core-utils\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { IPhantomReporter } from \"gatsby-cli\"\nimport {\n  JobInput,\n  InternalJob,\n  MESSAGE_TYPES,\n  IJobCreatedMessage,\n  IJobCompletedMessage,\n  IJobFailed,\n  IJobNotWhitelisted,\n  WorkerError,\n} from \"./types\"\n\ntype IncomingMessages = IJobCompletedMessage | IJobFailed | IJobNotWhitelisted\n\ntype OutgoingMessages = IJobCreatedMessage\n\nexport { InternalJob }\nexport type JobResultInterface = Record<string, unknown>\n\nlet activityForJobs: IPhantomReporter | null = null\nlet activeJobs = 0\nlet isListeningForMessages = false\nlet hasShownIPCDisabledWarning = false\n\nconst jobsInProcess: Map<\n  string,\n  { id: string; deferred: pDefer.DeferredPromise<Record<string, unknown>> }\n> = new Map()\nconst externalJobsMap: Map<\n  string,\n  { job: InternalJob; deferred: pDefer.DeferredPromise<any> }\n> = new Map()\n\n/**\n * We want to use absolute paths to make sure they are on the filesystem\n */\nfunction convertPathsToAbsolute(filePath: string): string {\n  if (!path.isAbsolute(filePath)) {\n    throw new Error(`${filePath} should be an absolute path.`)\n  }\n\n  return slash(filePath)\n}\n/**\n * Get contenthash of a file\n */\nfunction createFileHash(path: string): string {\n  return hasha.fromFileSync(path, { algorithm: `sha1` })\n}\n\nlet hasActiveJobs: pDefer.DeferredPromise<void> | null = null\n\nfunction hasExternalJobsEnabled(): boolean {\n  return (\n    process.env.ENABLE_GATSBY_EXTERNAL_JOBS === `true` ||\n    process.env.ENABLE_GATSBY_EXTERNAL_JOBS === `1`\n  )\n}\n\n/**\n * Get the local worker function and execute it on the user's machine\n */\nasync function runLocalWorker<T>(\n  workerFn: { ({ inputPaths, outputDir, args }: InternalJob): T },\n  job: InternalJob\n): Promise<T> {\n  await fs.ensureDir(job.outputDir)\n\n  return new Promise((resolve, reject) => {\n    // execute worker nextTick\n    // TODO should we think about threading/queueing here?\n    setImmediate(() => {\n      try {\n        resolve(\n          workerFn({\n            inputPaths: job.inputPaths,\n            outputDir: job.outputDir,\n            args: job.args,\n          } as InternalJob)\n        )\n      } catch (err) {\n        reject(new WorkerError(err))\n      }\n    })\n  })\n}\n\nfunction isJobsIPCMessage(msg: any): msg is IncomingMessages {\n  return (\n    msg &&\n    msg.type &&\n    msg.payload &&\n    msg.payload.id &&\n    externalJobsMap.has(msg.payload.id)\n  )\n}\n\nfunction listenForJobMessages(): void {\n  process.on(`message`, msg => {\n    if (isJobsIPCMessage(msg)) {\n      const { job, deferred } = externalJobsMap.get(msg.payload.id)!\n\n      switch (msg.type) {\n        case MESSAGE_TYPES.JOB_COMPLETED: {\n          deferred.resolve(msg.payload.result)\n          break\n        }\n        case MESSAGE_TYPES.JOB_FAILED: {\n          deferred.reject(new WorkerError(msg.payload.error))\n          break\n        }\n        case MESSAGE_TYPES.JOB_NOT_WHITELISTED: {\n          deferred.resolve(runJob(job, true))\n          break\n        }\n      }\n\n      externalJobsMap.delete(msg.payload.id)\n    }\n  })\n}\n\nfunction runExternalWorker(job: InternalJob): Promise<any> {\n  const deferred = pDefer<any>()\n\n  externalJobsMap.set(job.id, {\n    job,\n    deferred,\n  })\n\n  const jobCreatedMessage: OutgoingMessages = {\n    type: MESSAGE_TYPES.JOB_CREATED,\n    payload: job,\n  }\n\n  process.send!(jobCreatedMessage)\n\n  return deferred.promise\n}\n\n/**\n * Make sure we have everything we need to run a job\n * If we do, run it locally.\n * TODO add external job execution through ipc\n */\nfunction runJob(\n  job: InternalJob,\n  forceLocal = false\n): Promise<Record<string, unknown>> {\n  const { plugin } = job\n  try {\n    const worker = require(path.posix.join(plugin.resolve, `gatsby-worker.js`))\n    if (!worker[job.name]) {\n      throw new Error(`No worker function found for ${job.name}`)\n    }\n\n    if (!forceLocal && !job.plugin.isLocal && hasExternalJobsEnabled()) {\n      if (process.send) {\n        if (!isListeningForMessages) {\n          isListeningForMessages = true\n          listenForJobMessages()\n        }\n\n        return runExternalWorker(job)\n      } else {\n        // only show the offloading warning once\n        if (!hasShownIPCDisabledWarning) {\n          hasShownIPCDisabledWarning = true\n          reporter.warn(\n            `Offloading of a job failed as IPC could not be detected. Running job locally.`\n          )\n        }\n      }\n    }\n    return runLocalWorker(worker[job.name], job)\n  } catch (err) {\n    throw new Error(\n      `We couldn't find a gatsby-worker.js(${plugin.resolve}/gatsby-worker.js) file for ${plugin.name}@${plugin.version}`\n    )\n  }\n}\n\nfunction isInternalJob(job: JobInput | InternalJob): job is InternalJob {\n  return (\n    (job as InternalJob).id !== undefined &&\n    (job as InternalJob).contentDigest !== undefined\n  )\n}\n\n/**\n * Create an internal job object\n */\nexport function createInternalJob(\n  job: JobInput | InternalJob,\n  plugin: { name: string; version: string; resolve: string }\n): InternalJob {\n  // It looks like we already have an augmented job so we shouldn't redo this work\n  if (isInternalJob(job)) {\n    return job\n  }\n\n  const { name, inputPaths, outputDir, args } = job\n\n  // TODO see if we can make this async, filehashing might be expensive to wait for\n  // currently this needs to be sync as we could miss jobs to have been scheduled and\n  // are still processing their hashes\n  const inputPathsWithContentDigest = inputPaths.map((pth: string) => {\n    return {\n      path: convertPathsToAbsolute(pth),\n      contentDigest: createFileHash(pth),\n    }\n  })\n\n  const internalJob: InternalJob = {\n    id: uuidv4(),\n    name,\n    contentDigest: ``,\n    inputPaths: inputPathsWithContentDigest,\n    outputDir: convertPathsToAbsolute(outputDir),\n    args,\n    plugin: {\n      name: plugin.name,\n      version: plugin.version,\n      resolve: plugin.resolve,\n      isLocal: !plugin.resolve.includes(`/node_modules/`),\n    },\n  }\n\n  // generate a contentDigest based on all parameters including file content\n  internalJob.contentDigest = createContentDigest({\n    name: job.name,\n    inputPaths: internalJob.inputPaths.map(\n      inputPath => inputPath.contentDigest\n    ),\n    outputDir: internalJob.outputDir,\n    args: internalJob.args,\n    plugin: internalJob.plugin,\n  })\n\n  return internalJob\n}\n\n/**\n * Creates a job\n */\nexport async function enqueueJob(\n  job: InternalJob\n): Promise<Record<string, unknown>> {\n  // When we already have a job that's executing, return the same promise.\n  // we have another check in our createJobV2 action to return jobs that have been done in a previous gatsby run\n  if (jobsInProcess.has(job.contentDigest)) {\n    return jobsInProcess.get(job.contentDigest)!.deferred.promise\n  }\n\n  if (activeJobs === 0) {\n    hasActiveJobs = pDefer<void>()\n  }\n\n  // Bump active jobs\n  activeJobs++\n  if (!activityForJobs) {\n    activityForJobs = reporter.phantomActivity(`Running jobs v2`)\n    activityForJobs!.start()\n  }\n\n  const deferred = pDefer<Record<string, unknown>>()\n  jobsInProcess.set(job.contentDigest, {\n    id: job.id,\n    deferred,\n  })\n\n  try {\n    const result = await runJob(job)\n    // this check is to keep our worker results consistent for cloud\n    if (result != null && !_.isPlainObject(result)) {\n      throw new Error(\n        `Result of a worker should be an object, type of \"${typeof result}\" was given`\n      )\n    }\n    deferred.resolve(result)\n  } catch (err) {\n    deferred.reject(new WorkerError(err))\n  } finally {\n    // when all jobs are done we end the activity\n    if (--activeJobs === 0) {\n      hasActiveJobs!.resolve()\n      activityForJobs!.end()\n      // eslint-disable-next-line require-atomic-updates\n      activityForJobs = null\n    }\n  }\n\n  return deferred.promise\n}\n\n/**\n * Get in progress job promise\n */\nexport function getInProcessJobPromise(\n  contentDigest: string\n): Promise<Record<string, unknown>> | undefined {\n  return jobsInProcess.get(contentDigest)?.deferred.promise\n}\n\n/**\n * Remove a job from our inProgressQueue to reduce memory usage\n */\nexport function removeInProgressJob(contentDigest: string): void {\n  jobsInProcess.delete(contentDigest)\n}\n\n/**\n * Wait for all processing jobs to have finished\n */\nexport function waitUntilAllJobsComplete(): Promise<void> {\n  return hasActiveJobs ? hasActiveJobs.promise : Promise.resolve()\n}\n\nexport function isJobStale(\n  job: Partial<InternalJob> & { inputPaths: InternalJob[\"inputPaths\"] }\n): boolean {\n  const areInputPathsStale = job.inputPaths.some(inputPath => {\n    // does the inputPath still exists?\n    if (!fs.existsSync(inputPath.path)) {\n      return true\n    }\n\n    // check if we're talking about the same file\n    const fileHash = createFileHash(inputPath.path)\n    return fileHash !== inputPath.contentDigest\n  })\n\n  return areInputPathsStale\n}\n"],"file":"manager.js"}