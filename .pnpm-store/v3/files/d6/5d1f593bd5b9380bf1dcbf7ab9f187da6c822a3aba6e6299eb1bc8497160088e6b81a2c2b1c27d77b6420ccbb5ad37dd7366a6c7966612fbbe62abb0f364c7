{"version":3,"sources":["../../../src/utils/webpack/force-css-hmr-for-edge-cases.ts"],"names":["ForceCssHMRForEdgeCases","constructor","hackCounter","previouslySeenCss","Set","name","apply","compiler","hooks","thisCompilation","tap","compilation","fullHash","chunkGraph","records","chunkModuleHashes","seenCssInThisCompilation","cssRemovedInThisCompilation","newOrUpdatedCss","chunk","chunks","getModuleHash","module","codeGenerationResults","has","runtime","getHash","modules","getChunkModulesIterable","undefined","key","id","identifier","originalBlankCssHash","rawRequest","blankCssKey","isUsingMiniCssExtract","loaders","find","loader","includes","add","delete","hash","size","String"],"mappings":"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","sourcesContent":["import { Compiler, Module } from \"webpack\"\n\n/**\n * This is total hack that is meant to handle:\n *  - https://github.com/webpack-contrib/mini-css-extract-plugin/issues/706\n *  - https://github.com/webpack-contrib/mini-css-extract-plugin/issues/708\n * The way it works it is looking up what HotModuleReplacementPlugin checks internally\n * and tricks it by checking up if any modules that uses mini-css-extract-plugin\n * changed or was newly added and then modifying blank.css hash.\n * blank.css is css module that is used by all pages and is there from the start\n * so changing hash of that _should_ ensure that:\n *  - when new css is imported it will reload css\n *  - when css imported by not loaded (by runtime) page template changes it will reload css\n */\nexport class ForceCssHMRForEdgeCases {\n  private name: string\n  private originalBlankCssHash: string | undefined\n  private blankCssKey: string | undefined\n  private hackCounter = 0\n  private previouslySeenCss: Set<string> = new Set<string>()\n\n  constructor() {\n    this.name = `ForceCssHMRForEdgeCases`\n  }\n\n  apply(compiler: Compiler): void {\n    compiler.hooks.thisCompilation.tap(this.name, compilation => {\n      compilation.hooks.fullHash.tap(this.name, () => {\n        const chunkGraph = compilation.chunkGraph\n        const records = compilation.records\n\n        if (!records.chunkModuleHashes) {\n          return\n        }\n\n        const seenCssInThisCompilation = new Set<string>()\n        /**\n         * We will get list of css modules that are removed in this compilation\n         * by starting with list of css used in last compilation and removing\n         * all modules that are used in this one.\n         */\n        const cssRemovedInThisCompilation = this.previouslySeenCss\n\n        let newOrUpdatedCss = false\n\n        for (const chunk of compilation.chunks) {\n          const getModuleHash = (module: Module): string => {\n            if (compilation.codeGenerationResults.has(module, chunk.runtime)) {\n              return compilation.codeGenerationResults.getHash(\n                module,\n                chunk.runtime\n              )\n            } else {\n              return chunkGraph.getModuleHash(module, chunk.runtime)\n            }\n          }\n\n          const modules = chunkGraph.getChunkModulesIterable(chunk)\n\n          if (modules !== undefined) {\n            for (const module of modules) {\n              const key = `${chunk.id}|${module.identifier()}`\n\n              if (\n                !this.originalBlankCssHash &&\n                // @ts-ignore - exists on NormalModule but not Module\n                module.rawRequest === `./blank.css`\n              ) {\n                this.blankCssKey = key\n                this.originalBlankCssHash =\n                  records.chunkModuleHashes[this.blankCssKey]\n              }\n\n              // @ts-ignore - exists on NormalModule but not Module\n              const isUsingMiniCssExtract = module.loaders?.find(loader =>\n                loader?.loader?.includes(`mini-css-extract-plugin`)\n              )\n\n              if (isUsingMiniCssExtract) {\n                seenCssInThisCompilation.add(key)\n                cssRemovedInThisCompilation.delete(key)\n\n                const hash = getModuleHash(module)\n                if (records.chunkModuleHashes[key] !== hash) {\n                  newOrUpdatedCss = true\n                }\n              }\n            }\n          }\n        }\n\n        // If css file was edited or new css import was added (`newOrUpdatedCss`)\n        // or if css import was removed (`cssRemovedInThisCompilation.size > 0`)\n        // trick Webpack's HMR into thinking `blank.css` file changed.\n        if (\n          (newOrUpdatedCss || cssRemovedInThisCompilation.size > 0) &&\n          this.originalBlankCssHash &&\n          this.blankCssKey\n        ) {\n          records.chunkModuleHashes[this.blankCssKey] =\n            this.originalBlankCssHash + String(this.hackCounter++)\n        }\n\n        this.previouslySeenCss = seenCssInThisCompilation\n      })\n    })\n  }\n}\n"],"file":"force-css-hmr-for-edge-cases.js"}