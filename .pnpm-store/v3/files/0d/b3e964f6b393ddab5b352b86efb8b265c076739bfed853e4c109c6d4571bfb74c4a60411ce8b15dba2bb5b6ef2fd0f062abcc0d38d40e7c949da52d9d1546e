{"version":3,"sources":["../../../src/redux/actions/restricted.ts"],"names":["actions","addThirdPartySchema","schema","plugin","traceId","type","payload","createTypes","types","Array","isArray","map","parseTypeDef","createFieldExtension","extension","dispatch","getState","name","fieldExtensions","schemaCustomization","report","error","reservedExtensionNames","includes","printTypeDefinitions","path","include","exclude","withFieldTypes","createResolverContext","context","replace","withDeprecationWarning","actionName","action","api","allowedIn","args","warn","a","join","withErrorMessage","nodeAPIs","Object","keys","require","ALLOWED_IN","DEPRECATED_IN","set","availableActionsByAPI","mapAvailableActionsToAPIs","restrictions","actionNames","forEach","deprecatedIn","forbiddenIn","filter"],"mappings":";;;;;;;AAAA;;AAIA;;AACA;;AACA;;AA4BO,MAAMA,OAAO,GAAG;AACrB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,mBAAmB,EAAE,CACnB;AAAEC,IAAAA;AAAF,GADmB,EAEnBC,MAFmB,EAGnBC,OAHmB,KAIM;AACzB,WAAO;AACLC,MAAAA,IAAI,EAAG,wBADF;AAELF,MAAAA,MAFK;AAGLC,MAAAA,OAHK;AAILE,MAAAA,OAAO,EAAEJ;AAJJ,KAAP;AAMD,GAzBoB;;AA2BrB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEK,EAAAA,WAAW,EAAE,CACXC,KADW,EAMXL,MANW,EAOXC,OAPW,KAQM;AACjB,WAAO;AACLC,MAAAA,IAAI,EAAG,cADF;AAELF,MAAAA,MAFK;AAGLC,MAAAA,OAHK;AAILE,MAAAA,OAAO,EAAEG,KAAK,CAACC,OAAN,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","sourcesContent":["import { camelCase } from \"lodash\"\nimport { GraphQLSchema, GraphQLOutputType } from \"graphql\"\nimport { ActionCreator } from \"redux\"\nimport { ThunkAction } from \"redux-thunk\"\nimport report from \"gatsby-cli/lib/reporter\"\nimport { parseTypeDef } from \"../../schema/types/type-defs\"\nimport {\n  GraphQLFieldExtensionDefinition,\n  reservedExtensionNames,\n} from \"../../schema/extensions\"\nimport { GatsbyGraphQLType } from \"../../schema/types/type-builders\"\nimport {\n  IGatsbyPlugin,\n  ActionsUnion,\n  IAddThirdPartySchema,\n  ICreateTypes,\n  IGatsbyState,\n  ICreateFieldExtension,\n  IPrintTypeDefinitions,\n  ICreateResolverContext,\n  IGatsbyPluginContext,\n} from \"../types\"\n\ntype RestrictionActionNames =\n  | \"createFieldExtension\"\n  | \"createTypes\"\n  | \"createResolverContext\"\n  | \"addThirdPartySchema\"\n  | \"printTypeDefinitions\"\n\ntype SomeActionCreator =\n  | ActionCreator<ActionsUnion>\n  | ActionCreator<ThunkAction<any, IGatsbyState, any, ActionsUnion>>\n\nexport const actions = {\n  /**\n   * Add a third-party schema to be merged into main schema. Schema has to be a\n   * graphql-js GraphQLSchema object.\n   *\n   * This schema is going to be merged as-is. This can easily break the main\n   * Gatsby schema, so it's user's responsibility to make sure it doesn't happen\n   * (by e.g. namespacing the schema).\n   *\n   * @availableIn [createSchemaCustomization, sourceNodes]\n   *\n   * @param {Object} $0\n   * @param {GraphQLSchema} $0.schema GraphQL schema to add\n   */\n  addThirdPartySchema: (\n    { schema }: { schema: GraphQLSchema },\n    plugin: IGatsbyPlugin,\n    traceId?: string\n  ): IAddThirdPartySchema => {\n    return {\n      type: `ADD_THIRD_PARTY_SCHEMA`,\n      plugin,\n      traceId,\n      payload: schema,\n    }\n  },\n\n  /**\n   * Add type definitions to the GraphQL schema.\n   *\n   * @availableIn [createSchemaCustomization, sourceNodes]\n   *\n   * @param {string | GraphQLOutputType | GatsbyGraphQLType | string[] | GraphQLOutputType[] | GatsbyGraphQLType[]} types Type definitions\n   *\n   * Type definitions can be provided either as\n   * [`graphql-js` types](https://graphql.org/graphql-js/), in\n   * [GraphQL schema definition language (SDL)](https://graphql.org/learn/)\n   * or using Gatsby Type Builders available on the `schema` API argument.\n   *\n   * Things to note:\n   * * type definitions targeting node types, i.e. `MarkdownRemark` and others\n   *   added in `sourceNodes` or `onCreateNode` APIs, need to implement the\n   *   `Node` interface. Interface fields will be added automatically, but it\n   *   is mandatory to label those types with `implements Node`.\n   * * by default, explicit type definitions from `createTypes` will be merged\n   *   with inferred field types, and default field resolvers for `Date` (which\n   *   adds formatting options) and `File` (which resolves the field value as\n   *   a `relativePath` foreign-key field) are added. This behavior can be\n   *   customised with `@infer`, `@dontInfer` directives or extensions. Fields\n   *   may be assigned resolver (and other option like args) with additional\n   *   directives. Currently `@dateformat`, `@link`, `@fileByRelativePath` and\n   *   `@proxy` are available.\n   *\n   *\n   * Schema customization controls:\n   * * `@infer` - run inference on the type and add fields that don't exist on the\n   * defined type to it.\n   * * `@dontInfer` - don't run any inference on the type\n   *\n   * Extensions to add resolver options:\n   * * `@dateformat` - add date formatting arguments. Accepts `formatString` and\n   *   `locale` options that sets the defaults for this field\n   * * `@link` - connect to a different Node. Arguments `by` and `from`, which\n   *   define which field to compare to on a remote node and which field to use on\n   *   the source node\n   * * `@fileByRelativePath` - connect to a File node. Same arguments. The\n   *   difference from link is that this normalizes the relative path to be\n   *   relative from the path where source node is found.\n   * * `@proxy` - in case the underlying node data contains field names with\n   *   characters that are invalid in GraphQL, `proxy` allows to explicitly\n   *   proxy those properties to fields with valid field names. Takes a `from` arg.\n   *\n   *\n   * @example\n   * exports.createSchemaCustomization = ({ actions }) => {\n   *   const { createTypes } = actions\n   *   const typeDefs = `\n   *     \"\"\"\n   *     Markdown Node\n   *     \"\"\"\n   *     type MarkdownRemark implements Node @infer {\n   *       frontmatter: Frontmatter!\n   *     }\n   *\n   *     \"\"\"\n   *     Markdown Frontmatter\n   *     \"\"\"\n   *     type Frontmatter @infer {\n   *       title: String!\n   *       author: AuthorJson! @link\n   *       date: Date! @dateformat\n   *       published: Boolean!\n   *       tags: [String!]!\n   *     }\n   *\n   *     \"\"\"\n   *     Author information\n   *     \"\"\"\n   *     # Does not include automatically inferred fields\n   *     type AuthorJson implements Node @dontInfer {\n   *       name: String!\n   *       birthday: Date! @dateformat(locale: \"ru\")\n   *     }\n   *   `\n   *   createTypes(typeDefs)\n   * }\n   *\n   * // using Gatsby Type Builder API\n   * exports.createSchemaCustomization = ({ actions, schema }) => {\n   *   const { createTypes } = actions\n   *   const typeDefs = [\n   *     schema.buildObjectType({\n   *       name: 'MarkdownRemark',\n   *       fields: {\n   *         frontmatter: 'Frontmatter!'\n   *       },\n   *       interfaces: ['Node'],\n   *       extensions: {\n   *         infer: true,\n   *       },\n   *     }),\n   *     schema.buildObjectType({\n   *       name: 'Frontmatter',\n   *       fields: {\n   *         title: {\n   *           type: 'String!',\n   *           resolve(parent) {\n   *             return parent.title || '(Untitled)'\n   *           }\n   *         },\n   *         author: {\n   *           type: 'AuthorJson'\n   *           extensions: {\n   *             link: {},\n   *           },\n   *         }\n   *         date: {\n   *           type: 'Date!'\n   *           extensions: {\n   *             dateformat: {},\n   *           },\n   *         },\n   *         published: 'Boolean!',\n   *         tags: '[String!]!',\n   *       }\n   *     }),\n   *     schema.buildObjectType({\n   *       name: 'AuthorJson',\n   *       fields: {\n   *         name: 'String!'\n   *         birthday: {\n   *           type: 'Date!'\n   *           extensions: {\n   *             dateformat: {\n   *               locale: 'ru',\n   *             },\n   *           },\n   *         },\n   *       },\n   *       interfaces: ['Node'],\n   *       extensions: {\n   *         infer: false,\n   *       },\n   *     }),\n   *   ]\n   *   createTypes(typeDefs)\n   * }\n   */\n  createTypes: (\n    types:\n      | string\n      | GraphQLOutputType\n      | GatsbyGraphQLType<any, any>\n      | Array<string | GraphQLOutputType | GatsbyGraphQLType<any, any>>,\n    plugin: IGatsbyPlugin,\n    traceId?: string\n  ): ICreateTypes => {\n    return {\n      type: `CREATE_TYPES`,\n      plugin,\n      traceId,\n      payload: Array.isArray(types)\n        ? types.map(parseTypeDef)\n        : parseTypeDef(types),\n    }\n  },\n\n  /**\n   * Add a field extension to the GraphQL schema.\n   *\n   * Extensions allow defining custom behavior which can be added to fields\n   * via directive (in SDL) or on the `extensions` prop (with Type Builders).\n   *\n   * The extension definition takes a `name`, an `extend` function, and optional\n   * extension `args` for options. The `extend` function has to return a (partial)\n   * field config, and receives the extension options and the previous field config\n   * as arguments.\n   *\n   * @availableIn [createSchemaCustomization, sourceNodes]\n   *\n   * @param {GraphQLFieldExtensionDefinition} extension The field extension definition\n   * @example\n   * exports.createSchemaCustomization = ({ actions }) => {\n   *   const { createFieldExtension } = actions\n   *   createFieldExtension({\n   *     name: 'motivate',\n   *     args: {\n   *       caffeine: 'Int'\n   *     },\n   *     extend(options, prevFieldConfig) {\n   *       return {\n   *         type: 'String',\n   *         args: {\n   *           sunshine: {\n   *             type: 'Int',\n   *             defaultValue: 0,\n   *           },\n   *         },\n   *         resolve(source, args, context, info) {\n   *           const motivation = (options.caffeine || 0) - args.sunshine\n   *           if (motivation > 5) return 'Work! Work! Work!'\n   *           return 'Maybe tomorrow.'\n   *         },\n   *       }\n   *     },\n   *   })\n   * }\n   */\n  createFieldExtension:\n    (\n      extension: GraphQLFieldExtensionDefinition,\n      plugin: IGatsbyPlugin,\n      traceId?: string\n    ): ThunkAction<\n      void,\n      IGatsbyState,\n      Record<string, unknown>,\n      ICreateFieldExtension\n    > =>\n    (dispatch, getState): void => {\n      const { name } = extension || {}\n      const { fieldExtensions } = getState().schemaCustomization\n\n      if (!name) {\n        report.error(\n          `The provided field extension must have a \\`name\\` property.`\n        )\n      } else if (reservedExtensionNames.includes(name)) {\n        report.error(\n          `The field extension name \\`${name}\\` is reserved for internal use.`\n        )\n      } else if (fieldExtensions[name]) {\n        report.error(\n          `A field extension with the name \\`${name}\\` has already been registered.`\n        )\n      } else {\n        dispatch({\n          type: `CREATE_FIELD_EXTENSION`,\n          plugin,\n          traceId,\n          payload: { name, extension },\n        })\n      }\n    },\n\n  /**\n   * Write GraphQL schema to file\n   *\n   * Writes out inferred and explicitly specified type definitions. This is not\n   * the full GraphQL schema, but only the types necessary to recreate all type\n   * definitions, i.e. it does not include directives, built-ins, and derived\n   * types for filtering, sorting, pagination etc. Optionally, you can define a\n   * list of types to include/exclude. This is recommended to avoid including\n   * definitions for plugin-created types.\n   *\n   * The first object parameter is required, however all the fields in the object are optional.\n   *\n   * @availableIn [createSchemaCustomization]\n   *\n   * @param {object} $0\n   * @param {string} [$0.path] The path to the output file, defaults to `schema.gql`\n   * @param {object} [$0.include] Configure types to include\n   * @param {string[]} [$0.include.types] Only include these types\n   * @param {string[]} [$0.include.plugins] Only include types owned by these plugins\n   * @param {object} [$0.exclude] Configure types to exclude\n   * @param {string[]} [$0.exclude.types] Do not include these types\n   * @param {string[]} [$0.exclude.plugins] Do not include types owned by these plugins\n   * @param {boolean} [$0.withFieldTypes] Include field types, defaults to `true`\n   * @example\n   * exports.createSchemaCustomization = ({ actions }) => {\n   *   // This code writes a GraphQL schema to a file named `schema.gql`.\n   *   actions.printTypeDefinitions({})\n   * }\n   * @example\n   * exports.createSchemaCustomization = ({ actions }) => {\n   *   // This code writes a GraphQL schema to a file named `schema.gql`, but this time it does not include field types.\n   *   actions.printTypeDefinitions({ withFieldTypes: false })\n   * }\n   */\n  printTypeDefinitions: (\n    {\n      path = `schema.gql`,\n      include,\n      exclude,\n      withFieldTypes = true,\n    }: {\n      path?: string\n      include?: { types?: Array<string>; plugins?: Array<string> }\n      exclude?: { types?: Array<string>; plugins?: Array<string> }\n      withFieldTypes?: boolean\n    },\n    plugin: IGatsbyPlugin,\n    traceId?: string\n  ): IPrintTypeDefinitions => {\n    return {\n      type: `PRINT_SCHEMA_REQUESTED`,\n      plugin,\n      traceId,\n      payload: {\n        path,\n        include,\n        exclude,\n        withFieldTypes,\n      },\n    }\n  },\n\n  /**\n   * Make functionality available on field resolver `context`\n   *\n   * @availableIn [createSchemaCustomization]\n   *\n   * @param {object} context Object to make available on `context`.\n   * When called from a plugin, the context value will be namespaced under\n   * the camel-cased plugin name without the \"gatsby-\" prefix\n   * @example\n   * const getHtml = md => remark().use(html).process(md)\n   * exports.createSchemaCustomization = ({ actions }) => {\n   *   actions.createResolverContext({ getHtml })\n   * }\n   * // The context value can then be accessed in any field resolver like this:\n   * exports.createSchemaCustomization = ({ actions, schema }) => {\n   *   actions.createTypes(schema.buildObjectType({\n   *     name: 'Test',\n   *     interfaces: ['Node'],\n   *     fields: {\n   *       md: {\n   *         type: 'String!',\n   *         async resolve(source, args, context, info) {\n   *           const processed = await context.transformerRemark.getHtml(source.internal.contents)\n   *           return processed.contents\n   *         }\n   *       }\n   *     }\n   *   }))\n   * }\n   */\n  createResolverContext:\n    (\n      context: IGatsbyPluginContext,\n      plugin: IGatsbyPlugin,\n      traceId?: string\n    ): ThunkAction<\n      void,\n      IGatsbyState,\n      Record<string, unknown>,\n      ICreateResolverContext\n    > =>\n    (dispatch): void => {\n      if (!context || typeof context !== `object`) {\n        report.error(\n          `Expected context value passed to \\`createResolverContext\\` to be an object. Received \"${context}\".`\n        )\n      } else {\n        const { name } = plugin || {}\n        const payload =\n          !name || name === `default-site-plugin`\n            ? context\n            : { [camelCase(name.replace(/^gatsby-/, ``))]: context }\n        dispatch({\n          type: `CREATE_RESOLVER_CONTEXT`,\n          plugin,\n          traceId,\n          payload,\n        })\n      }\n    },\n}\n\nconst withDeprecationWarning =\n  (\n    actionName: RestrictionActionNames,\n    action: SomeActionCreator,\n    api: API,\n    allowedIn: Array<API>\n  ): SomeActionCreator =>\n  (...args: Array<any>): ReturnType<ActionCreator<any>> => {\n    report.warn(\n      `Calling \\`${actionName}\\` in the \\`${api}\\` API is deprecated. ` +\n        `Please use: ${allowedIn.map(a => `\\`${a}\\``).join(`, `)}.`\n    )\n    return action(...args)\n  }\n\nconst withErrorMessage =\n  (actionName: RestrictionActionNames, api: API, allowedIn: Array<API>) =>\n  () =>\n  // return a thunk that does not dispatch anything\n  (): void => {\n    report.error(\n      `\\`${actionName}\\` is not available in the \\`${api}\\` API. ` +\n        `Please use: ${allowedIn.map(a => `\\`${a}\\``).join(`, `)}.`\n    )\n  }\n\nconst nodeAPIs = Object.keys(require(`../../utils/api-node-docs`))\n\nconst ALLOWED_IN = `ALLOWED_IN`\nconst DEPRECATED_IN = `DEPRECATED_IN`\n\ntype API = string\n\ntype Restrictions = Record<\n  RestrictionActionNames,\n  Partial<{\n    ALLOWED_IN: Array<API>\n    DEPRECATED_IN: Array<API>\n  }>\n>\n\ntype AvailableActionsByAPI = Record<\n  API,\n  { [K in RestrictionActionNames]: SomeActionCreator }\n>\n\nconst set = (\n  availableActionsByAPI: Record<string, any>,\n  api: API,\n  actionName: RestrictionActionNames,\n  action: SomeActionCreator\n): void => {\n  availableActionsByAPI[api] = availableActionsByAPI[api] || {}\n  availableActionsByAPI[api][actionName] = action\n}\n\nconst mapAvailableActionsToAPIs = (\n  restrictions: Restrictions\n): AvailableActionsByAPI => {\n  const availableActionsByAPI: AvailableActionsByAPI = {}\n\n  const actionNames = Object.keys(restrictions) as Array<\n    keyof typeof restrictions\n  >\n  actionNames.forEach(actionName => {\n    const action = actions[actionName]\n\n    const allowedIn: Array<API> = restrictions[actionName][ALLOWED_IN] || []\n    allowedIn.forEach(api =>\n      set(availableActionsByAPI, api, actionName, action)\n    )\n\n    const deprecatedIn: Array<API> =\n      restrictions[actionName][DEPRECATED_IN] || []\n    deprecatedIn.forEach(api =>\n      set(\n        availableActionsByAPI,\n        api,\n        actionName,\n        withDeprecationWarning(actionName, action, api, allowedIn)\n      )\n    )\n\n    const forbiddenIn = nodeAPIs.filter(\n      api => ![...allowedIn, ...deprecatedIn].includes(api)\n    )\n    forbiddenIn.forEach(api =>\n      set(\n        availableActionsByAPI,\n        api,\n        actionName,\n        withErrorMessage(actionName, api, allowedIn)\n      )\n    )\n  })\n\n  return availableActionsByAPI\n}\n\nexport const availableActionsByAPI = mapAvailableActionsToAPIs({\n  createFieldExtension: {\n    [ALLOWED_IN]: [`sourceNodes`, `createSchemaCustomization`],\n  },\n  createTypes: {\n    [ALLOWED_IN]: [`sourceNodes`, `createSchemaCustomization`],\n    [DEPRECATED_IN]: [`onPreInit`, `onPreBootstrap`],\n  },\n  createResolverContext: {\n    [ALLOWED_IN]: [`createSchemaCustomization`],\n  },\n  addThirdPartySchema: {\n    [ALLOWED_IN]: [`sourceNodes`, `createSchemaCustomization`],\n    [DEPRECATED_IN]: [`onPreInit`, `onPreBootstrap`],\n  },\n  printTypeDefinitions: {\n    [ALLOWED_IN]: [`createSchemaCustomization`],\n  },\n})\n"],"file":"restricted.js"}