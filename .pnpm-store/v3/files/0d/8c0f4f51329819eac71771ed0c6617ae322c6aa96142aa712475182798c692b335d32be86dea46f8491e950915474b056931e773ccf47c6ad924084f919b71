"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three"),t=require("fflate"),r=require("../curves/NURBSCurve.cjs.js");let n,o,a;require("../curves/NURBSUtils.cjs.js");class s extends e.Loader{constructor(e){super(e)}load(t,r,n,o){const a=this,s=""===a.path?e.LoaderUtils.extractUrlBase(t):a.path,i=new e.FileLoader(this.manager);i.setPath(a.path),i.setResponseType("arraybuffer"),i.setRequestHeader(a.requestHeader),i.setWithCredentials(a.withCredentials),i.load(t,(function(e){try{r(a.parse(e,s))}catch(e){o?o(e):console.error(e),a.manager.itemError(t)}}),n,o)}parse(t,r){if(function(e){const t="Kaydara FBX Binary  \0";return e.byteLength>=t.length&&t===T(e,0,t.length)}(t))n=(new p).parse(t);else{const e=T(t);if(!function(e){const t=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let r=0;function n(t){const n=e[t-1];return e=e.slice(r+t),r++,n}for(let e=0;e<t.length;++e){if(n(1)===t[e])return!1}return!0}(e))throw new Error("THREE.FBXLoader: Unknown format.");if(f(e)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+f(e));n=(new u).parse(e)}const o=new e.TextureLoader(this.manager).setPath(this.resourcePath||r).setCrossOrigin(this.crossOrigin);return new i(o,this.manager).parse(n)}}class i{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){o=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),r=this.parseMaterials(t),n=this.parseDeformers(),s=(new l).parse(n);return this.parseScene(n,s,r),a}parseConnections(){const e=new Map;if("Connections"in n){n.Connections.connections.forEach((function(t){const r=t[0],n=t[1],o=t[2];e.has(r)||e.set(r,{parents:[],children:[]});const a={ID:n,relationship:o};e.get(r).parents.push(a),e.has(n)||e.set(n,{parents:[],children:[]});const s={ID:r,relationship:o};e.get(n).children.push(s)}))}return e}parseImages(){const e={},t={};if("Video"in n.Objects){const r=n.Objects.Video;for(const n in r){const o=r[n];if(e[parseInt(n)]=o.RelativeFilename||o.Filename,"Content"in o){const e=o.Content instanceof ArrayBuffer&&o.Content.byteLength>0,a="string"==typeof o.Content&&""!==o.Content;if(e||a){const e=this.parseImage(r[n]);t[o.RelativeFilename||o.Filename]=e}}}}for(const r in e){const n=e[r];void 0!==t[n]?e[r]=t[n]:e[r]=e[r].split("\\").pop()}return e}parseImage(e){const t=e.Content,r=e.RelativeFilename||e.Filename,n=r.slice(r.lastIndexOf(".")+1).toLowerCase();let o;switch(n){case"bmp":o="image/bmp";break;case"jpg":case"jpeg":o="image/jpeg";break;case"png":o="image/png";break;case"tif":o="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",r),o="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+n+'" is not supported.')}if("string"==typeof t)return"data:"+o+";base64,"+t;{const e=new Uint8Array(t);return window.URL.createObjectURL(new Blob([e],{type:o}))}}parseTextures(e){const t=new Map;if("Texture"in n.Objects){const r=n.Objects.Texture;for(const n in r){const o=this.parseTexture(r[n],e);t.set(parseInt(n),o)}}return t}parseTexture(t,r){const n=this.loadTexture(t,r);n.ID=t.id,n.name=t.attrName;const o=t.WrapModeU,a=t.WrapModeV,s=void 0!==o?o.value:0,i=void 0!==a?a.value:0;if(n.wrapS=0===s?e.RepeatWrapping:e.ClampToEdgeWrapping,n.wrapT=0===i?e.RepeatWrapping:e.ClampToEdgeWrapping,"Scaling"in t){const e=t.Scaling.value;n.repeat.x=e[0],n.repeat.y=e[1]}return n}loadTexture(t,r){let n;const a=this.textureLoader.path,s=o.get(t.id).children;let i;void 0!==s&&s.length>0&&void 0!==r[s[0].ID]&&(n=r[s[0].ID],0!==n.indexOf("blob:")&&0!==n.indexOf("data:")||this.textureLoader.setPath(void 0));const l=t.FileName.slice(-3).toLowerCase();if("tga"===l){const r=this.manager.getHandler(".tga");null===r?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",t.RelativeFilename),i=new e.Texture):i=r.load(n)}else"psd"===l?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",t.RelativeFilename),i=new e.Texture):i=this.textureLoader.load(n);return this.textureLoader.setPath(a),i}parseMaterials(e){const t=new Map;if("Material"in n.Objects){const r=n.Objects.Material;for(const n in r){const o=this.parseMaterial(r[n],e);null!==o&&t.set(parseInt(n),o)}}return t}parseMaterial(t,r){const n=t.id,a=t.attrName;let s=t.ShadingModel;if("object"==typeof s&&(s=s.value),!o.has(n))return null;const i=this.parseParameters(t,r,n);let l;switch(s.toLowerCase()){case"phong":l=new e.MeshPhongMaterial;break;case"lambert":l=new e.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',s),l=new e.MeshPhongMaterial}return l.setValues(i),l.name=a,l}parseParameters(t,r,n){const a={};t.BumpFactor&&(a.bumpScale=t.BumpFactor.value),t.Diffuse?a.color=(new e.Color).fromArray(t.Diffuse.value):!t.DiffuseColor||"Color"!==t.DiffuseColor.type&&"ColorRGB"!==t.DiffuseColor.type||(a.color=(new e.Color).fromArray(t.DiffuseColor.value)),t.DisplacementFactor&&(a.displacementScale=t.DisplacementFactor.value),t.Emissive?a.emissive=(new e.Color).fromArray(t.Emissive.value):!t.EmissiveColor||"Color"!==t.EmissiveColor.type&&"ColorRGB"!==t.EmissiveColor.type||(a.emissive=(new e.Color).fromArray(t.EmissiveColor.value)),t.EmissiveFactor&&(a.emissiveIntensity=parseFloat(t.EmissiveFactor.value)),t.Opacity&&(a.opacity=parseFloat(t.Opacity.value)),a.opacity<1&&(a.transparent=!0),t.ReflectionFactor&&(a.reflectivity=t.ReflectionFactor.value),t.Shininess&&(a.shininess=t.Shininess.value),t.Specular?a.specular=(new e.Color).fromArray(t.Specular.value):t.SpecularColor&&"Color"===t.SpecularColor.type&&(a.specular=(new e.Color).fromArray(t.SpecularColor.value));const s=this;return o.get(n).children.forEach((function(t){const n=t.relationship;switch(n){case"Bump":a.bumpMap=s.getTexture(r,t.ID);break;case"Maya|TEX_ao_map":a.aoMap=s.getTexture(r,t.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":a.map=s.getTexture(r,t.ID),a.map.encoding=e.sRGBEncoding;break;case"DisplacementColor":a.displacementMap=s.getTexture(r,t.ID);break;case"EmissiveColor":a.emissiveMap=s.getTexture(r,t.ID),a.emissiveMap.encoding=e.sRGBEncoding;break;case"NormalMap":case"Maya|TEX_normal_map":a.normalMap=s.getTexture(r,t.ID);break;case"ReflectionColor":a.envMap=s.getTexture(r,t.ID),a.envMap.mapping=e.EquirectangularReflectionMapping,a.envMap.encoding=e.sRGBEncoding;break;case"SpecularColor":a.specularMap=s.getTexture(r,t.ID),a.specularMap.encoding=e.sRGBEncoding;break;case"TransparentColor":case"TransparencyFactor":a.alphaMap=s.getTexture(r,t.ID),a.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",n)}})),a}getTexture(e,t){return"LayeredTexture"in n.Objects&&t in n.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=o.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in n.Objects){const r=n.Objects.Deformer;for(const n in r){const a=r[n],s=o.get(parseInt(n));if("Skin"===a.attrType){const t=this.parseSkeleton(s,r);t.ID=n,s.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),t.geometryID=s.parents[0].ID,e[n]=t}else if("BlendShape"===a.attrType){const e={id:n};e.rawTargets=this.parseMorphTargets(s,r),e.id=n,s.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[n]=e}}}return{skeletons:e,morphTargets:t}}parseSkeleton(t,r){const n=[];return t.children.forEach((function(t){const o=r[t.ID];if("Cluster"!==o.attrType)return;const a={ID:t.ID,indices:[],weights:[],transformLink:(new e.Matrix4).fromArray(o.TransformLink.a)};"Indexes"in o&&(a.indices=o.Indexes.a,a.weights=o.Weights.a),n.push(a)})),{rawBones:n,bones:[]}}parseMorphTargets(e,t){const r=[];for(let n=0;n<e.children.length;n++){const a=e.children[n],s=t[a.ID],i={name:s.attrName,initialWeight:s.DeformPercent,id:s.id,fullWeights:s.FullWeights.a};if("BlendShapeChannel"!==s.attrType)return;i.geoID=o.get(parseInt(a.ID)).children.filter((function(e){return void 0===e.relationship}))[0].ID,r.push(i)}return r}parseScene(t,r,s){a=new e.Group;const i=this.parseModels(t.skeletons,r,s),l=n.Objects.Model,u=this;i.forEach((function(e){const t=l[e.ID];u.setLookAtProperties(e,t);o.get(e.ID).parents.forEach((function(t){const r=i.get(t.ID);void 0!==r&&r.add(e)})),null===e.parent&&a.add(e)})),this.bindSkeleton(t.skeletons,r,i),this.createAmbientLight(),this.setupMorphMaterials(),a.traverse((function(e){if(e.userData.transformData){e.parent&&(e.userData.transformData.parentMatrix=e.parent.matrix,e.userData.transformData.parentMatrixWorld=e.parent.matrixWorld);const t=x(e.userData.transformData);e.applyMatrix4(t),e.updateWorldMatrix()}}));const p=(new c).parse();1===a.children.length&&a.children[0].isGroup&&(a.children[0].animations=p,a=a.children[0]),a.animations=p}parseModels(t,r,a){const s=new Map,i=n.Objects.Model;for(const n in i){const l=parseInt(n),c=i[n],u=o.get(l);let p=this.buildSkeleton(u,t,l,c.attrName);if(!p){switch(c.attrType){case"Camera":p=this.createCamera(u);break;case"Light":p=this.createLight(u);break;case"Mesh":p=this.createMesh(u,r,a);break;case"NurbsCurve":p=this.createCurve(u,r);break;case"LimbNode":case"Root":p=new e.Bone;break;case"Null":default:p=new e.Group}p.name=c.attrName?e.PropertyBinding.sanitizeNodeName(c.attrName):"",p.ID=l}this.getTransformData(p,c),s.set(l,p)}return s}buildSkeleton(t,r,n,o){let a=null;return t.parents.forEach((function(t){for(const s in r){const i=r[s];i.rawBones.forEach((function(r,s){if(r.ID===t.ID){const t=a;a=new e.Bone,a.matrixWorld.copy(r.transformLink),a.name=o?e.PropertyBinding.sanitizeNodeName(o):"",a.ID=n,i.bones[s]=a,null!==t&&a.add(t)}}))}})),a}createCamera(t){let r,o;if(t.children.forEach((function(e){const t=n.Objects.NodeAttribute[e.ID];void 0!==t&&(o=t)})),void 0===o)r=new e.Object3D;else{let t=0;void 0!==o.CameraProjectionType&&1===o.CameraProjectionType.value&&(t=1);let n=1;void 0!==o.NearPlane&&(n=o.NearPlane.value/1e3);let a=1e3;void 0!==o.FarPlane&&(a=o.FarPlane.value/1e3);let s=window.innerWidth,i=window.innerHeight;void 0!==o.AspectWidth&&void 0!==o.AspectHeight&&(s=o.AspectWidth.value,i=o.AspectHeight.value);const l=s/i;let c=45;void 0!==o.FieldOfView&&(c=o.FieldOfView.value);const u=o.FocalLength?o.FocalLength.value:null;switch(t){case 0:r=new e.PerspectiveCamera(c,l,n,a),null!==u&&r.setFocalLength(u);break;case 1:r=new e.OrthographicCamera(-s/2,s/2,i/2,-i/2,n,a);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+t+"."),r=new e.Object3D}}return r}createLight(t){let r,o;if(t.children.forEach((function(e){const t=n.Objects.NodeAttribute[e.ID];void 0!==t&&(o=t)})),void 0===o)r=new e.Object3D;else{let t;t=void 0===o.LightType?0:o.LightType.value;let n=16777215;void 0!==o.Color&&(n=(new e.Color).fromArray(o.Color.value));let a=void 0===o.Intensity?1:o.Intensity.value/100;void 0!==o.CastLightOnObject&&0===o.CastLightOnObject.value&&(a=0);let s=0;void 0!==o.FarAttenuationEnd&&(s=void 0!==o.EnableFarAttenuation&&0===o.EnableFarAttenuation.value?0:o.FarAttenuationEnd.value);const i=1;switch(t){case 0:r=new e.PointLight(n,a,s,i);break;case 1:r=new e.DirectionalLight(n,a);break;case 2:let t=Math.PI/3;void 0!==o.InnerAngle&&(t=e.MathUtils.degToRad(o.InnerAngle.value));let l=0;void 0!==o.OuterAngle&&(l=e.MathUtils.degToRad(o.OuterAngle.value),l=Math.max(l,1)),r=new e.SpotLight(n,a,s,t,l,i);break;default:console.warn("THREE.FBXLoader: Unknown light type "+o.LightType.value+", defaulting to a PointLight."),r=new e.PointLight(n,a)}void 0!==o.CastShadows&&1===o.CastShadows.value&&(r.castShadow=!0)}return r}createMesh(t,r,n){let o,a=null,s=null;const i=[];return t.children.forEach((function(e){r.has(e.ID)&&(a=r.get(e.ID)),n.has(e.ID)&&i.push(n.get(e.ID))})),i.length>1?s=i:i.length>0?s=i[0]:(s=new e.MeshPhongMaterial({color:13421772}),i.push(s)),"color"in a.attributes&&i.forEach((function(e){e.vertexColors=!0})),a.FBX_Deformer?(i.forEach((function(e){e.skinning=!0})),o=new e.SkinnedMesh(a,s),o.normalizeSkinWeights()):o=new e.Mesh(a,s),o}createCurve(t,r){const n=t.children.reduce((function(e,t){return r.has(t.ID)&&(e=r.get(t.ID)),e}),null),o=new e.LineBasicMaterial({color:3342591,linewidth:1});return new e.Line(n,o)}getTransformData(e,t){const r={};"InheritType"in t&&(r.inheritType=parseInt(t.InheritType.value)),r.eulerOrder="RotationOrder"in t?I(t.RotationOrder.value):"ZYX","Lcl_Translation"in t&&(r.translation=t.Lcl_Translation.value),"PreRotation"in t&&(r.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(r.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(r.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(r.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(r.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(r.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(r.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(r.rotationPivot=t.RotationPivot.value),e.userData.transformData=r}setLookAtProperties(t,r){if("LookAtProperty"in r){o.get(t.ID).children.forEach((function(r){if("LookAtProperty"===r.relationship){const o=n.Objects.Model[r.ID];if("Lcl_Translation"in o){const r=o.Lcl_Translation.value;void 0!==t.target?(t.target.position.fromArray(r),a.add(t.target)):t.lookAt((new e.Vector3).fromArray(r))}}}))}}bindSkeleton(t,r,n){const a=this.parsePoseNodes();for(const s in t){const i=t[s];o.get(parseInt(i.ID)).parents.forEach((function(t){if(r.has(t.ID)){const r=t.ID;o.get(r).parents.forEach((function(t){if(n.has(t.ID)){n.get(t.ID).bind(new e.Skeleton(i.bones),a[t.ID])}}))}}))}}parsePoseNodes(){const t={};if("Pose"in n.Objects){const r=n.Objects.Pose;for(const n in r)if("BindPose"===r[n].attrType){const o=r[n].PoseNode;Array.isArray(o)?o.forEach((function(r){t[r.Node]=(new e.Matrix4).fromArray(r.Matrix.a)})):t[o.Node]=(new e.Matrix4).fromArray(o.Matrix.a)}}return t}createAmbientLight(){if("GlobalSettings"in n&&"AmbientColor"in n.GlobalSettings){const t=n.GlobalSettings.AmbientColor.value,r=t[0],o=t[1],s=t[2];if(0!==r||0!==o||0!==s){const t=new e.Color(r,o,s);a.add(new e.AmbientLight(t,1))}}}setupMorphMaterials(){const e=this;a.traverse((function(t){t.isMesh&&t.geometry.morphAttributes.position&&t.geometry.morphAttributes.position.length&&(Array.isArray(t.material)?t.material.forEach((function(r,n){e.setupMorphMaterial(t,r,n)})):e.setupMorphMaterial(t,t.material))}))}setupMorphMaterial(e,t,r){const n=e.uuid,o=t.uuid;let s=!1;if(a.traverse((function(e){e.isMesh&&(Array.isArray(e.material)?e.material.forEach((function(t){t.uuid===o&&e.uuid!==n&&(s=!0)})):e.material.uuid===o&&e.uuid!==n&&(s=!0))})),!0===s){const n=t.clone();n.morphTargets=!0,void 0===r?e.material=n:e.material[r]=n}else t.morphTargets=!0}}class l{parse(e){const t=new Map;if("Geometry"in n.Objects){const r=n.Objects.Geometry;for(const n in r){const a=o.get(parseInt(n)),s=this.parseGeometry(a,r[n],e);t.set(parseInt(n),s)}}return t}parseGeometry(e,t,r){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,r);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,r){const o=r.skeletons,a=[],s=e.parents.map((function(e){return n.Objects.Model[e.ID]}));if(0===s.length)return;const i=e.children.reduce((function(e,t){return void 0!==o[t.ID]&&(e=o[t.ID]),e}),null);e.children.forEach((function(e){void 0!==r.morphTargets[e.ID]&&a.push(r.morphTargets[e.ID])}));const l=s[0],c={};"RotationOrder"in l&&(c.eulerOrder=I(l.RotationOrder.value)),"InheritType"in l&&(c.inheritType=parseInt(l.InheritType.value)),"GeometricTranslation"in l&&(c.translation=l.GeometricTranslation.value),"GeometricRotation"in l&&(c.rotation=l.GeometricRotation.value),"GeometricScaling"in l&&(c.scale=l.GeometricScaling.value);const u=x(c);return this.genGeometry(t,i,a,u)}genGeometry(t,r,n,o){const a=new e.BufferGeometry;t.attrName&&(a.name=t.attrName);const s=this.parseGeoNode(t,r),i=this.genBuffers(s),l=new e.Float32BufferAttribute(i.vertex,3);if(l.applyMatrix4(o),a.setAttribute("position",l),i.colors.length>0&&a.setAttribute("color",new e.Float32BufferAttribute(i.colors,3)),r&&(a.setAttribute("skinIndex",new e.Uint16BufferAttribute(i.weightsIndices,4)),a.setAttribute("skinWeight",new e.Float32BufferAttribute(i.vertexWeights,4)),a.FBX_Deformer=r),i.normal.length>0){const t=(new e.Matrix3).getNormalMatrix(o),r=new e.Float32BufferAttribute(i.normal,3);r.applyNormalMatrix(t),a.setAttribute("normal",r)}if(i.uvs.forEach((function(t,r){let n="uv"+(r+1).toString();0===r&&(n="uv"),a.setAttribute(n,new e.Float32BufferAttribute(i.uvs[r],2))})),s.material&&"AllSame"!==s.material.mappingType){let e=i.materialIndex[0],t=0;if(i.materialIndex.forEach((function(r,n){r!==e&&(a.addGroup(t,n-t,e),e=r,t=n)})),a.groups.length>0){const t=a.groups[a.groups.length-1],r=t.start+t.count;r!==i.materialIndex.length&&a.addGroup(r,i.materialIndex.length-r,e)}0===a.groups.length&&a.addGroup(0,i.materialIndex.length,i.materialIndex[0])}return this.addMorphTargets(a,t,n,o),a}parseGeoNode(e,t){const r={};if(r.vertexPositions=void 0!==e.Vertices?e.Vertices.a:[],r.vertexIndices=void 0!==e.PolygonVertexIndex?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(r.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(r.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(r.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){r.uv=[];let t=0;for(;e.LayerElementUV[t];)e.LayerElementUV[t].UV&&r.uv.push(this.parseUVs(e.LayerElementUV[t])),t++}return r.weightTable={},null!==t&&(r.skeleton=t,t.rawBones.forEach((function(e,t){e.indices.forEach((function(n,o){void 0===r.weightTable[n]&&(r.weightTable[n]=[]),r.weightTable[n].push({id:t,weight:e.weights[o]})}))}))),r}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let r=0,n=0,o=!1,a=[],s=[],i=[],l=[],c=[],u=[];const p=this;return e.vertexIndices.forEach((function(h,d){let f,m=!1;h<0&&(h^=-1,m=!0);let g=[],v=[];if(a.push(3*h,3*h+1,3*h+2),e.color){const t=y(d,r,h,e.color);i.push(t[0],t[1],t[2])}if(e.skeleton){if(void 0!==e.weightTable[h]&&e.weightTable[h].forEach((function(e){v.push(e.weight),g.push(e.id)})),v.length>4){o||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),o=!0);const e=[0,0,0,0],t=[0,0,0,0];v.forEach((function(r,n){let o=r,a=g[n];t.forEach((function(t,r,n){if(o>t){n[r]=o,o=t;const s=e[r];e[r]=a,a=s}}))})),g=e,v=t}for(;v.length<4;)v.push(0),g.push(0);for(let e=0;e<4;++e)c.push(v[e]),u.push(g[e])}if(e.normal){const t=y(d,r,h,e.normal);s.push(t[0],t[1],t[2])}e.material&&"AllSame"!==e.material.mappingType&&(f=y(d,r,h,e.material)[0]),e.uv&&e.uv.forEach((function(e,t){const n=y(d,r,h,e);void 0===l[t]&&(l[t]=[]),l[t].push(n[0]),l[t].push(n[1])})),n++,m&&(p.genFace(t,e,a,f,s,i,l,c,u,n),r++,n=0,a=[],s=[],i=[],l=[],c=[],u=[])})),t}genFace(e,t,r,n,o,a,s,i,l,c){for(let u=2;u<c;u++)e.vertex.push(t.vertexPositions[r[0]]),e.vertex.push(t.vertexPositions[r[1]]),e.vertex.push(t.vertexPositions[r[2]]),e.vertex.push(t.vertexPositions[r[3*(u-1)]]),e.vertex.push(t.vertexPositions[r[3*(u-1)+1]]),e.vertex.push(t.vertexPositions[r[3*(u-1)+2]]),e.vertex.push(t.vertexPositions[r[3*u]]),e.vertex.push(t.vertexPositions[r[3*u+1]]),e.vertex.push(t.vertexPositions[r[3*u+2]]),t.skeleton&&(e.vertexWeights.push(i[0]),e.vertexWeights.push(i[1]),e.vertexWeights.push(i[2]),e.vertexWeights.push(i[3]),e.vertexWeights.push(i[4*(u-1)]),e.vertexWeights.push(i[4*(u-1)+1]),e.vertexWeights.push(i[4*(u-1)+2]),e.vertexWeights.push(i[4*(u-1)+3]),e.vertexWeights.push(i[4*u]),e.vertexWeights.push(i[4*u+1]),e.vertexWeights.push(i[4*u+2]),e.vertexWeights.push(i[4*u+3]),e.weightsIndices.push(l[0]),e.weightsIndices.push(l[1]),e.weightsIndices.push(l[2]),e.weightsIndices.push(l[3]),e.weightsIndices.push(l[4*(u-1)]),e.weightsIndices.push(l[4*(u-1)+1]),e.weightsIndices.push(l[4*(u-1)+2]),e.weightsIndices.push(l[4*(u-1)+3]),e.weightsIndices.push(l[4*u]),e.weightsIndices.push(l[4*u+1]),e.weightsIndices.push(l[4*u+2]),e.weightsIndices.push(l[4*u+3])),t.color&&(e.colors.push(a[0]),e.colors.push(a[1]),e.colors.push(a[2]),e.colors.push(a[3*(u-1)]),e.colors.push(a[3*(u-1)+1]),e.colors.push(a[3*(u-1)+2]),e.colors.push(a[3*u]),e.colors.push(a[3*u+1]),e.colors.push(a[3*u+2])),t.material&&"AllSame"!==t.material.mappingType&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(o[0]),e.normal.push(o[1]),e.normal.push(o[2]),e.normal.push(o[3*(u-1)]),e.normal.push(o[3*(u-1)+1]),e.normal.push(o[3*(u-1)+2]),e.normal.push(o[3*u]),e.normal.push(o[3*u+1]),e.normal.push(o[3*u+2])),t.uv&&t.uv.forEach((function(t,r){void 0===e.uvs[r]&&(e.uvs[r]=[]),e.uvs[r].push(s[r][0]),e.uvs[r].push(s[r][1]),e.uvs[r].push(s[r][2*(u-1)]),e.uvs[r].push(s[r][2*(u-1)+1]),e.uvs[r].push(s[r][2*u]),e.uvs[r].push(s[r][2*u+1])}))}addMorphTargets(e,t,r,o){if(0===r.length)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const a=this;r.forEach((function(r){r.rawTargets.forEach((function(r){const s=n.Objects.Geometry[r.geoID];void 0!==s&&a.genMorphGeometry(e,t,s,o,r.name)}))}))}genMorphGeometry(t,r,n,o,a){const s=void 0!==r.PolygonVertexIndex?r.PolygonVertexIndex.a:[],i=void 0!==n.Vertices?n.Vertices.a:[],l=void 0!==n.Indexes?n.Indexes.a:[],c=3*t.attributes.position.count,u=new Float32Array(c);for(let e=0;e<l.length;e++){const t=3*l[e];u[t]=i[3*e],u[t+1]=i[3*e+1],u[t+2]=i[3*e+2]}const p={vertexIndices:s,vertexPositions:u},h=this.genBuffers(p),d=new e.Float32BufferAttribute(h.vertex,3);d.name=a||n.attrName,d.applyMatrix4(o),t.morphAttributes.position.push(d)}parseNormals(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Normals.a;let o=[];return"IndexToDirect"===r&&("NormalIndex"in e?o=e.NormalIndex.a:"NormalsIndex"in e&&(o=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:o,mappingType:t,referenceType:r}}parseUVs(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.UV.a;let o=[];return"IndexToDirect"===r&&(o=e.UVIndex.a),{dataSize:2,buffer:n,indices:o,mappingType:t,referenceType:r}}parseVertexColors(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Colors.a;let o=[];return"IndexToDirect"===r&&(o=e.ColorIndex.a),{dataSize:4,buffer:n,indices:o,mappingType:t,referenceType:r}}parseMaterialIndices(e){const t=e.MappingInformationType,r=e.ReferenceInformationType;if("NoMappingInformation"===t)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:r};const n=e.Materials.a,o=[];for(let e=0;e<n.length;++e)o.push(e);return{dataSize:1,buffer:n,indices:o,mappingType:t,referenceType:r}}parseNurbsGeometry(t){if(void 0===r.NURBSCurve)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new e.BufferGeometry;const n=parseInt(t.Order);if(isNaN(n))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",t.Order,t.id),new e.BufferGeometry;const o=n-1,a=t.KnotVector.a,s=[],i=t.Points.a;for(let t=0,r=i.length;t<r;t+=4)s.push((new e.Vector4).fromArray(i,t));let l,c;if("Closed"===t.Form)s.push(s[0]);else if("Periodic"===t.Form){l=o,c=a.length-1-l;for(let e=0;e<o;++e)s.push(s[e])}const u=new r.NURBSCurve(o,a,s,l,c).getPoints(7*s.length),p=new Float32Array(3*u.length);u.forEach((function(e,t){e.toArray(p,3*t)}));const h=new e.BufferGeometry;return h.setAttribute("position",new e.BufferAttribute(p,3)),h}}class c{parse(){const e=[],t=this.parseClips();if(void 0!==t)for(const r in t){const n=t[r],o=this.addClip(n);e.push(o)}return e}parseClips(){if(void 0===n.Objects.AnimationCurve)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=n.Objects.AnimationCurveNode,t=new Map;for(const r in e){const n=e[r];if(null!==n.attrName.match(/S|R|T|DeformPercent/)){const e={id:n.id,attr:n.attrName,curves:{}};t.set(e.id,e)}}return t}parseAnimationCurves(e){const t=n.Objects.AnimationCurve;for(const r in t){const n={id:t[r].id,times:t[r].KeyTime.a.map(m),values:t[r].KeyValueFloat.a},a=o.get(n.id);if(void 0!==a){const t=a.parents[0].ID,r=a.parents[0].relationship;r.match(/X/)?e.get(t).curves.x=n:r.match(/Y/)?e.get(t).curves.y=n:r.match(/Z/)?e.get(t).curves.z=n:r.match(/d|DeformPercent/)&&e.has(t)&&(e.get(t).curves.morph=n)}}}parseAnimationLayers(t){const r=n.Objects.AnimationLayer,s=new Map;for(const i in r){const r=[],l=o.get(parseInt(i));if(void 0!==l){l.children.forEach((function(s,i){if(t.has(s.ID)){const l=t.get(s.ID);if(void 0!==l.curves.x||void 0!==l.curves.y||void 0!==l.curves.z){if(void 0===r[i]){const t=o.get(s.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID;if(void 0!==t){const o=n.Objects.Model[t.toString()];if(void 0===o)return void console.warn("THREE.FBXLoader: Encountered a unused curve.",s);const l={modelName:o.attrName?e.PropertyBinding.sanitizeNodeName(o.attrName):"",ID:o.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};a.traverse((function(e){e.ID===o.id&&(l.transform=e.matrix,e.userData.transformData&&(l.eulerOrder=e.userData.transformData.eulerOrder))})),l.transform||(l.transform=new e.Matrix4),"PreRotation"in o&&(l.preRotation=o.PreRotation.value),"PostRotation"in o&&(l.postRotation=o.PostRotation.value),r[i]=l}}r[i]&&(r[i][l.attr]=l)}else if(void 0!==l.curves.morph){if(void 0===r[i]){const t=o.get(s.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID,a=o.get(t).parents[0].ID,l=o.get(a).parents[0].ID,c=o.get(l).parents[0].ID,u=n.Objects.Model[c],p={modelName:u.attrName?e.PropertyBinding.sanitizeNodeName(u.attrName):"",morphName:n.Objects.Deformer[t].attrName};r[i]=p}r[i][l.attr]=l}}})),s.set(parseInt(i),r)}}return s}parseAnimStacks(e){const t=n.Objects.AnimationStack,r={};for(const n in t){const a=o.get(parseInt(n)).children;a.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const s=e.get(a[0].ID);r[n]={name:t[n].attrName,layer:s}}return r}addClip(t){let r=[];const n=this;return t.layer.forEach((function(e){r=r.concat(n.generateTracks(e))})),new e.AnimationClip(t.name,-1,r)}generateTracks(t){const r=[];let n=new e.Vector3,o=new e.Quaternion,a=new e.Vector3;if(t.transform&&t.transform.decompose(n,o,a),n=n.toArray(),o=(new e.Euler).setFromQuaternion(o,t.eulerOrder).toArray(),a=a.toArray(),void 0!==t.T&&Object.keys(t.T.curves).length>0){const e=this.generateVectorTrack(t.modelName,t.T.curves,n,"position");void 0!==e&&r.push(e)}if(void 0!==t.R&&Object.keys(t.R.curves).length>0){const e=this.generateRotationTrack(t.modelName,t.R.curves,o,t.preRotation,t.postRotation,t.eulerOrder);void 0!==e&&r.push(e)}if(void 0!==t.S&&Object.keys(t.S.curves).length>0){const e=this.generateVectorTrack(t.modelName,t.S.curves,a,"scale");void 0!==e&&r.push(e)}if(void 0!==t.DeformPercent){const e=this.generateMorphTrack(t);void 0!==e&&r.push(e)}return r}generateVectorTrack(t,r,n,o){const a=this.getTimesForAllAxes(r),s=this.getKeyframeTrackValues(a,r,n);return new e.VectorKeyframeTrack(t+"."+o,a,s)}generateRotationTrack(t,r,n,o,a,s){void 0!==r.x&&(this.interpolateRotations(r.x),r.x.values=r.x.values.map(e.MathUtils.degToRad)),void 0!==r.y&&(this.interpolateRotations(r.y),r.y.values=r.y.values.map(e.MathUtils.degToRad)),void 0!==r.z&&(this.interpolateRotations(r.z),r.z.values=r.z.values.map(e.MathUtils.degToRad));const i=this.getTimesForAllAxes(r),l=this.getKeyframeTrackValues(i,r,n);void 0!==o&&((o=o.map(e.MathUtils.degToRad)).push(s),o=(new e.Euler).fromArray(o),o=(new e.Quaternion).setFromEuler(o)),void 0!==a&&((a=a.map(e.MathUtils.degToRad)).push(s),a=(new e.Euler).fromArray(a),a=(new e.Quaternion).setFromEuler(a).invert());const c=new e.Quaternion,u=new e.Euler,p=[];for(let e=0;e<l.length;e+=3)u.set(l[e],l[e+1],l[e+2],s),c.setFromEuler(u),void 0!==o&&c.premultiply(o),void 0!==a&&c.multiply(a),c.toArray(p,e/3*4);return new e.QuaternionKeyframeTrack(t+".quaternion",i,p)}generateMorphTrack(t){const r=t.DeformPercent.curves.morph,n=r.values.map((function(e){return e/100})),o=a.getObjectByName(t.modelName).morphTargetDictionary[t.morphName];return new e.NumberKeyframeTrack(t.modelName+".morphTargetInfluences["+o+"]",r.times,n)}getTimesForAllAxes(e){let t=[];if(void 0!==e.x&&(t=t.concat(e.x.times)),void 0!==e.y&&(t=t.concat(e.y.times)),void 0!==e.z&&(t=t.concat(e.z.times)),t=t.sort((function(e,t){return e-t})),t.length>1){let e=1,r=t[0];for(let n=1;n<t.length;n++){const o=t[n];o!==r&&(t[e]=o,r=o,e++)}t=t.slice(0,e)}return t}getKeyframeTrackValues(e,t,r){const n=r,o=[];let a=-1,s=-1,i=-1;return e.forEach((function(e){if(t.x&&(a=t.x.times.indexOf(e)),t.y&&(s=t.y.times.indexOf(e)),t.z&&(i=t.z.times.indexOf(e)),-1!==a){const e=t.x.values[a];o.push(e),n[0]=e}else o.push(n[0]);if(-1!==s){const e=t.y.values[s];o.push(e),n[1]=e}else o.push(n[1]);if(-1!==i){const e=t.z.values[i];o.push(e),n[2]=e}else o.push(n[2])})),o}interpolateRotations(e){for(let t=1;t<e.values.length;t++){const r=e.values[t-1],n=e.values[t]-r,o=Math.abs(n);if(o>=180){const a=o/180,s=n/a;let i=r+s;const l=e.times[t-1],c=(e.times[t]-l)/a;let u=l+c;const p=[],h=[];for(;u<e.times[t];)p.push(u),u+=c,h.push(i),i+=s;e.times=M(e.times,t,p),e.values=M(e.values,t,h)}}}}class u{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new d,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,r=e.split(/[\r\n]+/);return r.forEach((function(e,n){const o=e.match(/^[\s\t]*;/),a=e.match(/^[\s\t]*$/);if(o||a)return;const s=e.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),i=e.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),l=e.match("^\\t{"+(t.currentIndent-1)+"}}");s?t.parseNodeBegin(e,s):i?t.parseNodeProperty(e,i,r[++n]):l?t.popStack():e.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(e)})),this.allNodes}parseNodeBegin(e,t){const r=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map((function(e){return e.trim().replace(/^"/,"").replace(/"$/,"")})),o={name:r},a=this.parseNodeAttr(n),s=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(r,o):r in s?("PoseNode"===r?s.PoseNode.push(o):void 0!==s[r].id&&(s[r]={},s[r][s[r].id]=s[r]),""!==a.id&&(s[r][a.id]=o)):"number"==typeof a.id?(s[r]={},s[r][a.id]=o):"Properties70"!==r&&(s[r]="PoseNode"===r?[o]:o),"number"==typeof a.id&&(o.id=a.id),""!==a.name&&(o.attrName=a.name),""!==a.type&&(o.attrType=a.type),this.pushStack(o)}parseNodeAttr(e){let t=e[0];""!==e[0]&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let r="",n="";return e.length>1&&(r=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:r,type:n}}parseNodeProperty(e,t,r){let n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),o=t[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===n&&","===o&&(o=r.replace(/"/g,"").replace(/,$/,"").trim());const a=this.getCurrentNode();if("Properties70"!==a.name){if("C"===n){const e=o.split(",").slice(1),t=parseInt(e[0]),r=parseInt(e[1]);let s=o.split(",").slice(3);s=s.map((function(e){return e.trim().replace(/^"/,"")})),n="connections",o=[t,r],function(e,t){for(let r=0,n=e.length,o=t.length;r<o;r++,n++)e[n]=t[r]}(o,s),void 0===a[n]&&(a[n]=[])}"Node"===n&&(a.id=o),n in a&&Array.isArray(a[n])?a[n].push(o):"a"!==n?a[n]=o:a.a=o,this.setCurrentProp(a,n),"a"===n&&","!==o.slice(-1)&&(a.a=b(o))}else this.parseNodeSpecialProperty(e,n,o)}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,","!==e.slice(-1)&&(t.a=b(t.a))}parseNodeSpecialProperty(e,t,r){const n=r.split('",').map((function(e){return e.trim().replace(/^\"/,"").replace(/\s/,"_")})),o=n[0],a=n[1],s=n[2],i=n[3];let l=n[4];switch(a){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":l=parseFloat(l);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":l=b(l)}this.getPrevNode()[o]={type:a,type2:s,flag:i,value:l},this.setCurrentProp(this.getPrevNode(),o)}}class p{parse(e){const t=new h(e);t.skip(23);const r=t.getUint32();if(r<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+r);const n=new d;for(;!this.endOfContent(t);){const e=this.parseNode(t,r);null!==e&&n.add(e.name,e)}return n}endOfContent(e){return e.size()%16==0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const r={},n=t>=7500?e.getUint64():e.getUint32(),o=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const a=e.getUint8(),s=e.getString(a);if(0===n)return null;const i=[];for(let t=0;t<o;t++)i.push(this.parseProperty(e));const l=i.length>0?i[0]:"",c=i.length>1?i[1]:"",u=i.length>2?i[2]:"";for(r.singleProperty=1===o&&e.getOffset()===n;n>e.getOffset();){const n=this.parseNode(e,t);null!==n&&this.parseSubNode(s,r,n)}return r.propertyList=i,"number"==typeof l&&(r.id=l),""!==c&&(r.attrName=c),""!==u&&(r.attrType=u),""!==s&&(r.name=s),r}parseSubNode(e,t,r){if(!0===r.singleProperty){const e=r.propertyList[0];Array.isArray(e)?(t[r.name]=r,r.a=e):t[r.name]=e}else if("Connections"===e&&"C"===r.name){const e=[];r.propertyList.forEach((function(t,r){0!==r&&e.push(t)})),void 0===t.connections&&(t.connections=[]),t.connections.push(e)}else if("Properties70"===r.name){Object.keys(r).forEach((function(e){t[e]=r[e]}))}else if("Properties70"===e&&"P"===r.name){let e=r.propertyList[0],n=r.propertyList[1];const o=r.propertyList[2],a=r.propertyList[3];let s;0===e.indexOf("Lcl ")&&(e=e.replace("Lcl ","Lcl_")),0===n.indexOf("Lcl ")&&(n=n.replace("Lcl ","Lcl_")),s="Color"===n||"ColorRGB"===n||"Vector"===n||"Vector3D"===n||0===n.indexOf("Lcl_")?[r.propertyList[4],r.propertyList[5],r.propertyList[6]]:r.propertyList[4],t[e]={type:n,type2:o,flag:a,value:s}}else void 0===t[r.name]?"number"==typeof r.id?(t[r.name]={},t[r.name][r.id]=r):t[r.name]=r:"PoseNode"===r.name?(Array.isArray(t[r.name])||(t[r.name]=[t[r.name]]),t[r.name].push(r)):void 0===t[r.name][r.id]&&(t[r.name][r.id]=r)}parseProperty(e){const r=e.getString(1);let n;switch(r){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return n=e.getUint32(),e.getArrayBuffer(n);case"S":return n=e.getUint32(),e.getString(n);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const o=e.getUint32(),a=e.getUint32(),s=e.getUint32();if(0===a)switch(r){case"b":case"c":return e.getBooleanArray(o);case"d":return e.getFloat64Array(o);case"f":return e.getFloat32Array(o);case"i":return e.getInt32Array(o);case"l":return e.getInt64Array(o)}const i=t.unzlibSync(new Uint8Array(e.getArrayBuffer(s))),l=new h(i.buffer);switch(r){case"b":case"c":return l.getBooleanArray(o);case"d":return l.getFloat64Array(o);case"f":return l.getFloat32Array(o);case"i":return l.getInt32Array(o);case"l":return l.getInt64Array(o)}default:throw new Error("THREE.FBXLoader: Unknown property type "+r)}}}class h{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return 1==(1&this.getUint8())}getBooleanArray(e){const t=[];for(let r=0;r<e;r++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),2147483648&t?(t=4294967295&~t,e=4294967295&~e,4294967295===e&&(t=t+1&4294967295),e=e+1&4294967295,-(4294967296*t+e)):4294967296*t+e}getInt64Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),4294967296*t+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(t){let r=[];for(let e=0;e<t;e++)r[e]=this.getUint8();const n=r.indexOf(0);return n>=0&&(r=r.slice(0,n)),e.LoaderUtils.decodeText(new Uint8Array(r))}}class d{add(e,t){this[e]=t}}function f(e){const t=e.match(/FBXVersion: (\d+)/);if(t){return parseInt(t[1])}throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function m(e){return e/46186158e3}const g=[];function y(e,t,r,n){let o;switch(n.mappingType){case"ByPolygonVertex":o=e;break;case"ByPolygon":o=t;break;case"ByVertice":o=r;break;case"AllSame":o=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}"IndexToDirect"===n.referenceType&&(o=n.indices[o]);const a=o*n.dataSize,s=a+n.dataSize;return function(e,t,r,n){for(let o=r,a=0;o<n;o++,a++)e[a]=t[o];return e}(g,n.buffer,a,s)}const v=new e.Euler,w=new e.Vector3;function x(t){const r=new e.Matrix4,n=new e.Matrix4,o=new e.Matrix4,a=new e.Matrix4,s=new e.Matrix4,i=new e.Matrix4,l=new e.Matrix4,c=new e.Matrix4,u=new e.Matrix4,p=new e.Matrix4,h=new e.Matrix4,d=new e.Matrix4,f=t.inheritType?t.inheritType:0;if(t.translation&&r.setPosition(w.fromArray(t.translation)),t.preRotation){const r=t.preRotation.map(e.MathUtils.degToRad);r.push(t.eulerOrder),n.makeRotationFromEuler(v.fromArray(r))}if(t.rotation){const r=t.rotation.map(e.MathUtils.degToRad);r.push(t.eulerOrder),o.makeRotationFromEuler(v.fromArray(r))}if(t.postRotation){const r=t.postRotation.map(e.MathUtils.degToRad);r.push(t.eulerOrder),a.makeRotationFromEuler(v.fromArray(r)),a.invert()}t.scale&&s.scale(w.fromArray(t.scale)),t.scalingOffset&&l.setPosition(w.fromArray(t.scalingOffset)),t.scalingPivot&&i.setPosition(w.fromArray(t.scalingPivot)),t.rotationOffset&&c.setPosition(w.fromArray(t.rotationOffset)),t.rotationPivot&&u.setPosition(w.fromArray(t.rotationPivot)),t.parentMatrixWorld&&(h.copy(t.parentMatrix),p.copy(t.parentMatrixWorld));const m=(new e.Matrix4).copy(n).multiply(o).multiply(a),g=new e.Matrix4;g.extractRotation(p);const y=new e.Matrix4;y.copyPosition(p);const x=new e.Matrix4,I=(new e.Matrix4).copy(y).invert().multiply(p);x.copy(g).invert().multiply(I);const b=s,T=new e.Matrix4;if(0===f)T.copy(g).multiply(m).multiply(x).multiply(b);else if(1===f)T.copy(g).multiply(x).multiply(m).multiply(b);else{const t=(new e.Matrix4).scale((new e.Vector3).setFromMatrixScale(h)),r=(new e.Matrix4).copy(t).invert(),n=(new e.Matrix4).copy(x).multiply(r);T.copy(g).multiply(m).multiply(n).multiply(b)}const M=new e.Matrix4;M.copy(u).invert();const A=new e.Matrix4;A.copy(i).invert();let E=new e.Matrix4;E.copy(r).multiply(c).multiply(u).multiply(n).multiply(o).multiply(a).multiply(M).multiply(l).multiply(i).multiply(s).multiply(A);const D=(new e.Matrix4).copyPosition(E),L=(new e.Matrix4).copy(p).multiply(D);return d.copyPosition(L),E=(new e.Matrix4).copy(d).multiply(T),E.premultiply(p.invert()),E}function I(e){const t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===(e=e||0)?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),t[0]):t[e]}function b(e){return e.split(",").map((function(e){return parseFloat(e)}))}function T(t,r,n){return void 0===r&&(r=0),void 0===n&&(n=t.byteLength),e.LoaderUtils.decodeText(new Uint8Array(t,r,n))}function M(e,t,r){return e.slice(0,t).concat(r).concat(e.slice(t))}exports.FBXLoader=s;
