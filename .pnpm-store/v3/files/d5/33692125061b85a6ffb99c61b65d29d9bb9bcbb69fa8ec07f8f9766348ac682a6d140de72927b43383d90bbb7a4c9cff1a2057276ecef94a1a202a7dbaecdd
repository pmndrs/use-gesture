{"version":3,"sources":["../../../src/utils/webpack/static-query-mapper.ts"],"names":["doesModuleMatchResourcePath","resourcePath","webpackModule","ConcatenatedModule","resource","modules","some","innerModule","getRealPath","cache","componentPath","has","set","path","resolve","get","getWebpackModulesByResourcePaths","staticQueries","components","realPathCache","Map","webpackModulesByStaticQueryId","webpackModulesByComponentId","forEach","id","staticQuery","staticQueryComponentPath","component","componentComponentPath","getChunkGroupsDerivedFromEntrypoint","chunkGroup","entrypoint","hasParent","chunkGroups","parentChunkGroup","getParents","newChunkGroup","concat","StaticQueryMapper","constructor","store","name","apply","compiler","staticQueryComponents","getState","hooks","done","tap","stats","compilation","parentCompilation","chunkGraph","staticQueriesByChunkGroup","chunkGroupsWithPageComponents","Set","chunkGroupsByComponentPath","appEntryPoint","entrypoints","staticQueryId","chunkGroupsDerivedFromEntrypoints","chunk","getModuleChunksIterable","groupsIterable","push","staticQueryHashes","hash","add","globalStaticQueries","allStaticQueries","Array","from","sort","staticQueriesByTemplate","dispatch","type","payload","pages","hasErrors","watchMode"],"mappings":"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","sourcesContent":["import path from \"path\"\nimport { Store } from \"redux\"\nimport { Compiler, Module, NormalModule, Compilation } from \"webpack\"\nimport ConcatenatedModule from \"webpack/lib/optimize/ConcatenatedModule\"\nimport { isEqual } from \"lodash\"\nimport {\n  IGatsbyState,\n  IGatsbyPageComponent,\n  IGatsbyStaticQueryComponents,\n} from \"../../redux/types\"\nimport { generateComponentChunkName } from \"../js-chunk-names\"\nimport { enqueueFlush } from \"../page-data\"\n\ntype ChunkGroup = Compilation[\"chunkGroups\"][0]\ntype EntryPoint = Compilation[\"asyncEntrypoints\"][0]\n\n/**\n * Checks if a module matches a resourcePath\n */\nfunction doesModuleMatchResourcePath(\n  resourcePath: string,\n  webpackModule: Module | NormalModule | ConcatenatedModule\n): boolean {\n  if (!(webpackModule instanceof ConcatenatedModule)) {\n    return (webpackModule as NormalModule).resource === resourcePath\n  }\n\n  // ConcatenatedModule is a collection of modules so we have to go deeper to actually get it\n  return webpackModule.modules.some(\n    innerModule => (innerModule as NormalModule).resource === resourcePath\n  )\n}\n\n/**\n * A helper to set/get path resolving\n */\nfunction getRealPath(\n  cache: Map<string, string>,\n  componentPath: string\n): string {\n  if (!cache.has(componentPath)) {\n    cache.set(componentPath, path.resolve(componentPath))\n  }\n\n  return cache.get(componentPath) as string\n}\n\n/**\n * Grab the actual webpackModule from the resourcePath\n * We return staticQueries and componentPaths cause that's what we care about\n */\nfunction getWebpackModulesByResourcePaths(\n  modules: Set<Module>,\n  staticQueries: IGatsbyState[\"staticQueryComponents\"],\n  components: IGatsbyState[\"components\"]\n): {\n  webpackModulesByStaticQueryId: Map<string, Module>\n  webpackModulesByComponentId: Map<string, Module>\n} {\n  const realPathCache = new Map<string, string>()\n  const webpackModulesByStaticQueryId = new Map<string, Module>()\n  const webpackModulesByComponentId = new Map<string, Module>()\n\n  modules.forEach(webpackModule => {\n    for (const [id, staticQuery] of staticQueries) {\n      const staticQueryComponentPath = getRealPath(\n        realPathCache,\n        staticQuery.componentPath\n      )\n\n      if (\n        !doesModuleMatchResourcePath(staticQueryComponentPath, webpackModule)\n      ) {\n        continue\n      }\n\n      webpackModulesByStaticQueryId.set(id, webpackModule)\n    }\n\n    for (const [id, component] of components) {\n      const componentComponentPath = getRealPath(\n        realPathCache,\n        component.componentPath\n      )\n      if (!doesModuleMatchResourcePath(componentComponentPath, webpackModule)) {\n        continue\n      }\n\n      webpackModulesByComponentId.set(id, webpackModule)\n    }\n  })\n\n  return { webpackModulesByStaticQueryId, webpackModulesByComponentId }\n}\n\n/**\n * Chunks can be async so the group might not represent a pageComponent group\n * We'll need to search for it.\n */\nfunction getChunkGroupsDerivedFromEntrypoint(\n  chunkGroup: ChunkGroup,\n  entrypoint: EntryPoint\n): Array<ChunkGroup> {\n  // when it's imported by any globals or async-requires we know we have the correct chunkgroups.\n  // Async modules won't have hasParent listed\n  if (chunkGroup.hasParent(entrypoint)) {\n    return [chunkGroup]\n  }\n\n  let chunkGroups: Array<ChunkGroup> = []\n  for (const parentChunkGroup of chunkGroup.getParents()) {\n    const newChunkGroup = getChunkGroupsDerivedFromEntrypoint(\n      parentChunkGroup,\n      entrypoint\n    )\n    chunkGroups = chunkGroups.concat(newChunkGroup)\n  }\n\n  return chunkGroups\n}\n\nexport class StaticQueryMapper {\n  private store: Store<IGatsbyState>\n  private name: string\n\n  constructor(store) {\n    this.store = store\n    this.name = `StaticQueryMapper`\n  }\n\n  apply(compiler: Compiler): void {\n    const { components, staticQueryComponents } = this.store.getState()\n\n    compiler.hooks.done.tap(this.name, stats => {\n      const compilation = stats.compilation\n      // We only care about the main compilation\n      // Chunkgraph should always be available when it's done but you know typescript.\n      if (compilation.compiler.parentCompilation || !compilation.chunkGraph) {\n        return\n      }\n\n      const staticQueriesByChunkGroup = new Map<ChunkGroup, Array<string>>()\n      const chunkGroupsWithPageComponents = new Set<ChunkGroup>()\n      const chunkGroupsByComponentPath = new Map<\n        IGatsbyPageComponent[\"componentPath\"],\n        ChunkGroup\n      >()\n\n      const { webpackModulesByStaticQueryId, webpackModulesByComponentId } =\n        getWebpackModulesByResourcePaths(\n          compilation.modules,\n          staticQueryComponents,\n          components\n        )\n\n      const appEntryPoint = (\n        compilation.entrypoints.has(`app`)\n          ? compilation.entrypoints.get(`app`)\n          : compilation.entrypoints.get(`commons`)\n      ) as EntryPoint\n\n      // group hashes by chunkGroup for ease of use\n      for (const [\n        staticQueryId,\n        webpackModule,\n      ] of webpackModulesByStaticQueryId) {\n        let chunkGroupsDerivedFromEntrypoints: Array<ChunkGroup> = []\n        for (const chunk of compilation.chunkGraph.getModuleChunksIterable(\n          webpackModule\n        )) {\n          for (const chunkGroup of chunk.groupsIterable) {\n            if (chunkGroup === appEntryPoint) {\n              chunkGroupsDerivedFromEntrypoints.push(chunkGroup)\n            } else {\n              chunkGroupsDerivedFromEntrypoints =\n                chunkGroupsDerivedFromEntrypoints.concat(\n                  getChunkGroupsDerivedFromEntrypoint(chunkGroup, appEntryPoint)\n                )\n            }\n          }\n        }\n\n        // loop over all component chunkGroups or global ones\n        chunkGroupsDerivedFromEntrypoints.forEach(chunkGroup => {\n          const staticQueryHashes =\n            staticQueriesByChunkGroup.get(chunkGroup) ?? []\n\n          staticQueryHashes.push(\n            (\n              staticQueryComponents.get(\n                staticQueryId\n              ) as IGatsbyStaticQueryComponents\n            ).hash\n          )\n\n          staticQueriesByChunkGroup.set(chunkGroup, staticQueryHashes)\n        })\n      }\n\n      // group chunkGroups by componentPaths for ease of use\n      for (const [\n        componentPath,\n        webpackModule,\n      ] of webpackModulesByComponentId) {\n        for (const chunk of compilation.chunkGraph.getModuleChunksIterable(\n          webpackModule\n        )) {\n          for (const chunkGroup of chunk.groupsIterable) {\n            // When it's a direct import from app entrypoint (async-requires) we know we have the correct chunkGroup\n            if (chunkGroup.name === generateComponentChunkName(componentPath)) {\n              chunkGroupsWithPageComponents.add(chunkGroup)\n              chunkGroupsByComponentPath.set(componentPath, chunkGroup)\n            }\n          }\n        }\n      }\n\n      let globalStaticQueries: Array<string> = []\n      for (const [chunkGroup, staticQueryHashes] of staticQueriesByChunkGroup) {\n        // When a chunkgroup is not part of a pageComponent we know it's part of a global group.\n        if (!chunkGroupsWithPageComponents.has(chunkGroup)) {\n          globalStaticQueries = globalStaticQueries.concat(staticQueryHashes)\n        }\n      }\n\n      components.forEach(component => {\n        const allStaticQueries = new Set(globalStaticQueries)\n        if (chunkGroupsByComponentPath.has(component.componentPath)) {\n          const chunkGroup = chunkGroupsByComponentPath.get(\n            component.componentPath\n          )\n          if (chunkGroup && staticQueriesByChunkGroup.has(chunkGroup)) {\n            ;(\n              staticQueriesByChunkGroup.get(chunkGroup) as Array<string>\n            ).forEach(staticQuery => {\n              allStaticQueries.add(staticQuery)\n            })\n          }\n        }\n\n        // modules, chunks, chunkgroups can all have not-deterministic orders so\n        // just sort array of static queries we produced to ensure final result is deterministic\n        const staticQueryHashes = Array.from(allStaticQueries).sort()\n\n        if (\n          !isEqual(\n            this.store\n              .getState()\n              .staticQueriesByTemplate.get(component.componentPath),\n            staticQueryHashes\n          )\n        ) {\n          this.store.dispatch({\n            type: `ADD_PENDING_TEMPLATE_DATA_WRITE`,\n            payload: {\n              componentPath: component.componentPath,\n              pages: component.pages,\n            },\n          })\n\n          this.store.dispatch({\n            type: `SET_STATIC_QUERIES_BY_TEMPLATE`,\n            payload: {\n              componentPath: component.componentPath,\n              staticQueryHashes,\n            },\n          })\n        }\n      })\n\n      // In dev mode we want to write page-data when compilation succeeds\n      if (!stats.hasErrors() && compiler.watchMode) {\n        enqueueFlush()\n      }\n    })\n  }\n}\n"],"file":"static-query-mapper.js"}