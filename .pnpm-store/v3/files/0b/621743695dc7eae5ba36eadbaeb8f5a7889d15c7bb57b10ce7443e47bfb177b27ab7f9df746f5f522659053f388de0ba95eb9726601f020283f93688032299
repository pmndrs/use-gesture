{"version":3,"sources":["../../src/utils/path.ts"],"names":["withBasePath","basePath","paths","withTrailingSlash","posixJoinWithLeadingSlash","path","posix","join","map","segment","index","getCommonDir","path1","path2","path1Segments","split","path2Segments","i","length","toLowerCase","joined","slice","MAX_PATH_SEGMENT_CHARS","MAX_PATH_SEGMENT_BYTES","SLICING_INDEX","pathSegmentRe","isMacOs","process","platform","isWindows","isNameTooLong","Buffer","from","tooLongSegmentsInPath","invalidFilenames","push","truncatePath","replace","match"],"mappings":";;;;;;;AAAA;;AACA;;AAEO,MAAMA,YAAY,GACtBC,QAAD,IACA,CAAC,GAAGC,KAAJ,KACE,+BAASD,QAAT,EAAmB,GAAGC,KAAtB,CAHG;;;;AAKA,MAAMC,iBAAiB,GAAIF,QAAD,IAA+B,GAAEA,QAAS,GAApE;;;;AAEP,MAAMG,yBAAyB,GAAIF,KAAD,IAChCG,cAAKC,KAAL,CAAWC,IAAX,CACE,GAAGL,KAAK,CAACM,GAAN,CAAU,CAACC,OAAD,EAAUC,KAAV,KACXD,OAAO,KAAM,EAAb,IAAkBC,KAAK,KAAK,CAA5B,GAAiC,GAAjC,GAAsCD,OADrC,CADL,CADF;;AAOO,MAAME,YAAY,GAAG,CAACC,KAAD,EAAgBC,KAAhB,KAA0C;AACpE,QAAMC,aAAa,GAAGF,KAAK,CAACG,KAAN,CAAY,OAAZ,CAAtB;AACA,QAAMC,aAAa,GAAGH,KAAK,CAACE,KAAN,CAAY,OAAZ,CAAtB;;AAEA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,aAAa,CAACI,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,QAAIA,CAAC,IAAID,aAAa,CAACE,MAAvB,EAA+B;AAC7B,aAAOd,yBAAyB,CAACY,aAAD,CAAhC;AACD,KAFD,MAEO,IACLF,aAAa,CAACG,CAAD,CAAb,CAAiBE,WAAjB,OAAmCH,aAAa,CAACC,CAAD,CAAb,CAAiBE,WAAjB,EAD9B,EAEL;AACA,YAAMC,MAAM,GAAGN,aAAa,CAACO,KAAd,CAAoB,CAApB,EAAuBJ,CAAvB,CAAf;AACA,aAAOb,yBAAyB,CAACgB,MAAD,CAAhC;AACD;AACF;;AAED,SAAOhB,yBAAyB,CAACU,aAAD,CAAhC;AACD,CAhBM,C,CAkBP;;;;AACA,MAAMQ,sBAAsB,GAAG,GAA/B;AACA,MAAMC,sBAAsB,GAAG,GAA/B;AACA,MAAMC,aAAa,GAAG,EAAtB;AACA,MAAMC,aAAa,GAAG,QAAtB;AAEA,MAAMC,OAAO,GAAGC,OAAO,CAACC,QAAR,KAAsB,QAAtC;AACA,MAAMC,SAAS,GAAGF,OAAO,CAACC,QAAR,KAAsB,OAAxC;;AAEA,MAAME,aAAa,GAAIrB,OAAD,IACpBiB,OAAO,IAAIG,SAAX,GACIpB,OAAO,CAACS,MAAR,GAAiBI,sBADrB,CAC4C;AAD5C,EAEIS,MAAM,CAACC,IAAP,CAAYvB,OAAZ,EAAqBS,MAArB,GAA8BK,sBAHpC,C,CAG2D;;;AAEpD,MAAMU,qBAAqB,GAAI5B,IAAD,IAAiC;AACpE,QAAM6B,gBAA+B,GAAG,EAAxC;;AACA,OAAK,MAAMzB,OAAX,IAAsBJ,IAAI,CAACU,KAAL,CAAY,GAAZ,CAAtB,EAAuC;AACrC,QAAIe,aAAa,CAACrB,OAAD,CAAjB,EAA4B;AAC1ByB,MAAAA,gBAAgB,CAACC,IAAjB,CAAsB1B,OAAtB;AACD;AACF;;AACD,SAAOyB,gBAAP;AACD,CARM;;;;AAUA,MAAME,YAAY,GAAI/B,IAAD,IAC1BA,IAAI,CAACgC,OAAL,CAAaZ,aAAb,EAA4Ba,KAAK,IAAI;AACnC,MAAIR,aAAa,CAACQ,KAAD,CAAjB,EAA0B;AACxB,WACEA,KAAK,CAACjB,KAAN,CAAY,CAAZ,EAAeG,aAAf,IACA,0CAAoBc,KAAK,CAACjB,KAAN,CAAYG,aAAZ,CAApB,CAFF;AAID;;AACD,SAAOc,KAAP;AACD,CARD,CADK","sourcesContent":["import path from \"path\"\nimport { joinPath, createContentDigest } from \"gatsby-core-utils\"\n\nexport const withBasePath =\n  (basePath: string) =>\n  (...paths: Array<string>): string =>\n    joinPath(basePath, ...paths)\n\nexport const withTrailingSlash = (basePath: string): string => `${basePath}/`\n\nconst posixJoinWithLeadingSlash = (paths: Array<string>): string =>\n  path.posix.join(\n    ...paths.map((segment, index) =>\n      segment === `` && index === 0 ? `/` : segment\n    )\n  )\n\nexport const getCommonDir = (path1: string, path2: string): string => {\n  const path1Segments = path1.split(/[/\\\\]/)\n  const path2Segments = path2.split(/[/\\\\]/)\n\n  for (let i = 0; i < path1Segments.length; i++) {\n    if (i >= path2Segments.length) {\n      return posixJoinWithLeadingSlash(path2Segments)\n    } else if (\n      path1Segments[i].toLowerCase() !== path2Segments[i].toLowerCase()\n    ) {\n      const joined = path1Segments.slice(0, i)\n      return posixJoinWithLeadingSlash(joined)\n    }\n  }\n\n  return posixJoinWithLeadingSlash(path1Segments)\n}\n\n// MacOS (APFS) and Windows (NTFS) filename length limit = 255 chars, Others = 255 bytes\nconst MAX_PATH_SEGMENT_CHARS = 255\nconst MAX_PATH_SEGMENT_BYTES = 255\nconst SLICING_INDEX = 50\nconst pathSegmentRe = /[^/]+/g\n\nconst isMacOs = process.platform === `darwin`\nconst isWindows = process.platform === `win32`\n\nconst isNameTooLong = (segment: string): boolean =>\n  isMacOs || isWindows\n    ? segment.length > MAX_PATH_SEGMENT_CHARS // MacOS (APFS) and Windows (NTFS) filename length limit (255 chars)\n    : Buffer.from(segment).length > MAX_PATH_SEGMENT_BYTES // Other (255 bytes)\n\nexport const tooLongSegmentsInPath = (path: string): Array<string> => {\n  const invalidFilenames: Array<string> = []\n  for (const segment of path.split(`/`)) {\n    if (isNameTooLong(segment)) {\n      invalidFilenames.push(segment)\n    }\n  }\n  return invalidFilenames\n}\n\nexport const truncatePath = (path: string): string =>\n  path.replace(pathSegmentRe, match => {\n    if (isNameTooLong(match)) {\n      return (\n        match.slice(0, SLICING_INDEX) +\n        createContentDigest(match.slice(SLICING_INDEX))\n      )\n    }\n    return match\n  })\n"],"file":"path.js"}