"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/defineProperty"),t=require("three"),o=require("../BufferGeometryUtils-9eb5c2e7.js");function s(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}require("../types/helpers.cjs.js");var i=s(e);const r=new t.Vector3,h=new t.Vector3;function n(e,t){const o=e.indexOf(t);o>-1&&e.splice(o,1)}class l{constructor(e,t){i.default(this,"position",void 0),i.default(this,"id",void 0),i.default(this,"faces",void 0),i.default(this,"neighbors",void 0),i.default(this,"collapseCost",void 0),i.default(this,"collapseNeighbor",void 0),i.default(this,"minCost",0),i.default(this,"totalCost",0),i.default(this,"costCount",0),this.position=e,this.id=t,this.faces=[],this.neighbors=[],this.collapseCost=0,this.collapseNeighbor=null}addUniqueNeighbor(e){var t,o;t=this.neighbors,o=e,-1===t.indexOf(o)&&t.push(o)}removeIfNonNeighbor(e){const t=this.neighbors,o=this.faces,s=t.indexOf(e);if(-1!==s){for(let t=0;t<o.length;t++)if(o[t].hasVertex(e))return;t.splice(s,1)}}}class a{constructor(e,o,s,r,h,n){i.default(this,"a",void 0),i.default(this,"b",void 0),i.default(this,"c",void 0),i.default(this,"v1",void 0),i.default(this,"v2",void 0),i.default(this,"v3",void 0),i.default(this,"normal",new t.Vector3),this.a=r,this.b=h,this.c=n,this.v1=e,this.v2=o,this.v3=s,this.computeNormal(),e.faces.push(this),e.addUniqueNeighbor(o),e.addUniqueNeighbor(s),o.faces.push(this),o.addUniqueNeighbor(e),o.addUniqueNeighbor(s),s.faces.push(this),s.addUniqueNeighbor(e),s.addUniqueNeighbor(o)}computeNormal(){const e=this.v1.position,t=this.v2.position,o=this.v3.position;r.subVectors(o,t),h.subVectors(e,t),r.cross(h).normalize(),this.normal.copy(r)}hasVertex(e){return e===this.v1||e===this.v2||e===this.v3}replaceVertex(e,t){e===this.v1?this.v1=t:e===this.v2?this.v2=t:e===this.v3&&(this.v3=t),n(e.faces,this),t.faces.push(this),e.removeIfNonNeighbor(this.v1),this.v1.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v2),this.v2.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v3),this.v3.removeIfNonNeighbor(e),this.v1.addUniqueNeighbor(this.v2),this.v1.addUniqueNeighbor(this.v3),this.v2.addUniqueNeighbor(this.v1),this.v2.addUniqueNeighbor(this.v3),this.v3.addUniqueNeighbor(this.v1),this.v3.addUniqueNeighbor(this.v2),this.computeNormal()}}exports.SimplifyModifier=class{constructor(){i.default(this,"computeEdgeCollapseCost",((e,t)=>{const o=t.position.distanceTo(e.position);let s=0;const i=[];let r,h,n,l=e.faces.length;for(r=0;r<l;r++)h=e.faces[r],h.hasVertex(t)&&i.push(h);for(r=0;r<l;r++){let t=1;h=e.faces[r];for(let e=0;e<i.length;e++){n=i[e];const o=h.normal.dot(n.normal);t=Math.min(t,(1.001-o)/2)}s=Math.max(s,t)}i.length<2&&(s=1);return o*s+0})),i.default(this,"computeEdgeCostAtVertex",(e=>{if(0===e.neighbors.length)return e.collapseNeighbor=null,void(e.collapseCost=-.01);e.collapseCost=1e5,e.collapseNeighbor=null;for(let t=0;t<e.neighbors.length;t++){const o=this.computeEdgeCollapseCost(e,e.neighbors[t]);e.collapseNeighbor||(e.collapseNeighbor=e.neighbors[t],e.collapseCost=o,e.minCost=o,e.totalCost=0,e.costCount=0),e.costCount++,e.totalCost+=o,o<e.minCost&&(e.collapseNeighbor=e.neighbors[t],e.minCost=o)}e.collapseCost=e.totalCost/e.costCount})),i.default(this,"removeFace",((e,t)=>{n(t,e),e.v1&&n(e.v1.faces,e),e.v2&&n(e.v2.faces,e),e.v3&&n(e.v3.faces,e);const o=[e.v1,e.v2,e.v3];let s,i;for(let e=0;e<3;e++)s=o[e],i=o[(e+1)%3],s&&i&&(s.removeIfNonNeighbor(i),i.removeIfNonNeighbor(s))})),i.default(this,"collapse",((e,t,o,s)=>{if(!s)return void this.removeVertex(o,e);let i;const r=[];for(i=0;i<o.neighbors.length;i++)r.push(o.neighbors[i]);for(i=o.faces.length-1;i>=0;i--)o.faces[i].hasVertex(s)&&this.removeFace(o.faces[i],t);for(i=o.faces.length-1;i>=0;i--)o.faces[i].replaceVertex(o,s);for(this.removeVertex(o,e),i=0;i<r.length;i++)this.computeEdgeCostAtVertex(r[i])})),i.default(this,"minimumCostEdge",(e=>{let t=e[0];for(let o=0;o<e.length;o++)e[o].collapseCost<t.collapseCost&&(t=e[o]);return t})),i.default(this,"modify",((e,s)=>{const i=(e=e.clone()).attributes;for(let t in i)"position"!==t&&e.deleteAttribute(t);const r=[],h=[],n=(e=o.mergeVertices(e)).getAttribute("position");for(let e=0;e<n.count;e++){const o=(new t.Vector3).fromBufferAttribute(n,e),s=new l(o,e);r.push(s)}const c=e.getIndex();if(null!==c)for(let e=0;e<c.count;e+=3){const t=c.getX(e),o=c.getX(e+1),s=c.getX(e+2),i=new a(r[t],r[o],r[s],t,o,s);h.push(i)}else for(let e=0;e<n.count;e+=3){const t=e,o=e+1,s=e+2,i=new a(r[t],r[o],r[s],t,o,s);h.push(i)}for(let e=0,t=r.length;e<t;e++)this.computeEdgeCostAtVertex(r[e]);let f,u=s;for(;u--;){if(f=this.minimumCostEdge(r),!f){console.log("THREE.SimplifyModifier: No next vertex");break}this.collapse(r,h,f,f.collapseNeighbor)}const d=new t.BufferGeometry,v=[];let g=[];for(let e=0;e<r.length;e++){const t=r[e].position;v.push(t.x,t.y,t.z)}for(let e=0;e<h.length;e++){const t=h[e],o=r.indexOf(t.v1),s=r.indexOf(t.v2),i=r.indexOf(t.v3);g.push(o,s,i)}return d.setAttribute("position",new t.Float32BufferAttribute(v,3)),d.setIndex(g),d}))}removeVertex(e,t){for(console.assert(0===e.faces.length);e.neighbors.length;){n(e.neighbors.pop().neighbors,e)}n(t,e)}};
