{"version":3,"sources":["../../../src/utils/worker/pool.ts"],"names":["create","numWorkers","Math","max","reporter","verbose","worker","WorkerPool","require","resolve","env","GATSBY_WORKER_POOL_WORKER","queriesChunkSize","Number","process","GATSBY_PARALLEL_QUERY_CHUNK_SIZE","runQueriesInWorkersQueue","pool","queryIds","chunkSize","staticQuerySegments","staticQueryIds","pageQuerySegments","pageQueryIds","activity","createProgress","length","start","all","setComponents","segment","single","runQueries","then","replayWorkerActions","tick","Promise","saveQueriesDependencies","end","mergeWorkerState","activityTimer","workerId","getWorkerInfo","state","String","queryStateChunk","queries","store","dispatch","type","payload","nextTick","actions","i","action"],"mappings":"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","sourcesContent":["import { WorkerPool } from \"gatsby-worker\"\nimport { chunk } from \"lodash\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { cpuCoreCount } from \"gatsby-core-utils\"\n\nimport { IGroupedQueryIds } from \"../../services\"\nimport { initJobsMessagingInMainProcess } from \"../jobs/worker-messaging\"\nimport { initReporterMessagingInMainProcess } from \"./reporter\"\n\nimport { GatsbyWorkerPool } from \"./types\"\nimport { loadPartialStateFromDisk, store } from \"../../redux\"\nimport { ActionsUnion, IGatsbyState } from \"../../redux/types\"\n\nexport type { GatsbyWorkerPool }\n\nexport const create = (): GatsbyWorkerPool => {\n  const numWorkers = Math.max(1, cpuCoreCount() - 1)\n  reporter.verbose(`Creating ${numWorkers} worker`)\n\n  const worker: GatsbyWorkerPool = new WorkerPool(require.resolve(`./child`), {\n    numWorkers,\n    env: {\n      GATSBY_WORKER_POOL_WORKER: `true`,\n    },\n  })\n\n  initJobsMessagingInMainProcess(worker)\n  initReporterMessagingInMainProcess(worker)\n\n  return worker\n}\n\nconst queriesChunkSize =\n  Number(process.env.GATSBY_PARALLEL_QUERY_CHUNK_SIZE) || 50\n\nexport async function runQueriesInWorkersQueue(\n  pool: GatsbyWorkerPool,\n  queryIds: IGroupedQueryIds,\n  chunkSize = queriesChunkSize\n): Promise<void> {\n  const staticQuerySegments = chunk(queryIds.staticQueryIds, chunkSize)\n  const pageQuerySegments = chunk(queryIds.pageQueryIds, chunkSize)\n\n  const activity = reporter.createProgress(\n    `run queries in workers`,\n    queryIds.staticQueryIds.length + queryIds.pageQueryIds.length\n  )\n  activity.start()\n\n  pool.all.setComponents()\n\n  for (const segment of staticQuerySegments) {\n    pool.single\n      .runQueries({ pageQueryIds: [], staticQueryIds: segment })\n      .then(replayWorkerActions)\n      .then(() => {\n        activity.tick(segment.length)\n      })\n  }\n\n  for (const segment of pageQuerySegments) {\n    pool.single\n      .runQueries({ pageQueryIds: segment, staticQueryIds: [] })\n      .then(replayWorkerActions)\n      .then(() => {\n        activity.tick(segment.length)\n      })\n  }\n\n  // note that we only await on this and not on anything before (`.setComponents()` or `.runQueries()`)\n  // because gatsby-worker will queue tasks internally and worker will never execute multiple tasks at the same time\n  // so awaiting `.saveQueriesDependencies()` is enough to make sure `.setComponents()` and `.runQueries()` finished\n  await Promise.all(pool.all.saveQueriesDependencies())\n  activity.end()\n}\n\nexport async function mergeWorkerState(pool: GatsbyWorkerPool): Promise<void> {\n  const activity = reporter.activityTimer(`Merge worker state`)\n  activity.start()\n\n  for (const { workerId } of pool.getWorkerInfo()) {\n    const state = loadPartialStateFromDisk([`queries`], String(workerId))\n    const queryStateChunk = state.queries as IGatsbyState[\"queries\"]\n    if (queryStateChunk) {\n      // When there are too little queries, some worker can be inactive and its state is empty\n      store.dispatch({\n        type: `MERGE_WORKER_QUERY_STATE`,\n        payload: {\n          workerId,\n          queryStateChunk,\n        },\n      })\n      await new Promise(resolve => process.nextTick(resolve))\n    }\n  }\n  activity.end()\n}\n\nasync function replayWorkerActions(\n  actions: Array<ActionsUnion>\n): Promise<void> {\n  let i = 1\n  for (const action of actions) {\n    store.dispatch(action)\n\n    // Give event loop some breath\n    if (i++ % 100 === 0) {\n      await new Promise(resolve => process.nextTick(resolve))\n    }\n  }\n}\n"],"file":"pool.js"}