{"version":3,"sources":["../../../src/redux/reducers/queries.ts"],"names":["FLAG_DIRTY_NEW_PAGE","FLAG_DIRTY_TEXT","FLAG_DIRTY_DATA","FLAG_DIRTY_PAGE_CONTEXT","FLAG_ERROR_EXTRACTION","FLAG_RUNNING_INFLIGHT","initialState","byNode","Map","byConnection","queryNodes","trackedQueries","trackedComponents","deletedQueries","Set","dirtyQueriesListToEmitViaWebsocket","initialQueryState","dirty","running","initialComponentState","componentPath","query","pages","errors","queriesReducer","state","action","type","path","payload","get","contextModified","registerQuery","setFlag","trackDirtyQuery","registerComponent","add","delete","apiName","queryId","component","values","clearNodeDependencies","clearConnectionDependencies","clear","hasFlag","set","id","nodeId","connection","addNodeDependency","addConnectionDependency","node","queriesByNode","queriesByConnection","internal","assertCorrectWorkerState","mergeWorkerDataDependencies","allFlags","flag","nodeQueries","queryIds","queryNodeIds","process","env","GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND","push","workerStateChunk","queryState","queryStateChunk","keys","queries","connectionName","workerId","size","Error"],"mappings":";;;;;;AAOsB;AAKf,MAAMA,mBAAmB,GAAG,MAA5B;;AACA,MAAMC,eAAe,GAAG,MAAxB;;AACA,MAAMC,eAAe,GAAG,MAAxB;;AACA,MAAMC,uBAAuB,GAAG,MAAhC;;AAEA,MAAMC,qBAAqB,GAAG,MAA9B;;AAEA,MAAMC,qBAAqB,GAAG,MAA9B;;;AAEP,MAAMC,YAAY,GAAG,MAA+B;AAClD,SAAO;AACLC,IAAAA,MAAM,EAAE,IAAIC,GAAJ,EADH;AAELC,IAAAA,YAAY,EAAE,IAAID,GAAJ,EAFT;AAGLE,IAAAA,UAAU,EAAE,IAAIF,GAAJ,EAHP;AAILG,IAAAA,cAAc,EAAE,IAAIH,GAAJ,EAJX;AAKLI,IAAAA,iBAAiB,EAAE,IAAIJ,GAAJ,EALd;AAMLK,IAAAA,cAAc,EAAE,IAAIC,GAAJ,EANX;AAOLC,IAAAA,kCAAkC,EAAE;AAP/B,GAAP;AASD,CAVD;;AAYA,MAAMC,iBAAiB,GAAG,MAAmB;AAC3C,SAAO;AACLC,IAAAA,KAAK,EAAE,CAAC,CADH;AACM;AACXC,IAAAA,OAAO,EAAE;AAFJ,GAAP;AAID,CALD;;AAOA,MAAMC,qBAAqB,GAAG,MAAuB;AACnD,SAAO;AACLC,IAAAA,aAAa,EAAG,EADX;AAELC,IAAAA,KAAK,EAAG,EAFH;AAGLC,IAAAA,KAAK,EAAE,IAAIR,GAAJ,EAHF;AAILS,IAAAA,MAAM,EAAE,CAJH,CAKL;;AALK,GAAP;AAOD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASC,cAAT,CACLC,KAA8B,GAAGnB,YAAY,EADxC,EAELoB,MAFK,EAGoB;AACzB,UAAQA,MAAM,CAACC,IAAf;AACE,SAAM,cAAN;AACE,aAAOrB,YAAY,EAAnB;;AAEF,SAAM,aAAN;AAAoB;AAClB,cAAM;AAAEsB,UAAAA,IAAF;AAAQR,UAAAA;AAAR,YAA0BM,MAAM,CAACG,OAAvC;AACA,YAAIR,KAAK,GAAGI,KAAK,CAACd,cAAN,CAAqBmB,GAArB,CAAyBF,IAAzB,CAAZ;;AACA,YAAI,CAACP,KAAD,IAAUK,MAAM,CAACK,eAArB,EAAsC;AACpCV,UAAAA,KAAK,GAAGW,aAAa,CAACP,KAAD,EAAQG,IAAR,CAArB;AACAP,UAAAA,KAAK,CAACJ,KAAN,GAAcgB,OAAO,CACnBZ,KAAK,CAACJ,KADa,EAEnBS,MAAM,CAACK,eAAP,GAAyB5B,uBAAzB,GAAmDH,mBAFhC,CAArB;AAIAyB,UAAAA,KAAK,GAAGS,eAAe,CAACT,KAAD,EAAQG,IAAR,CAAvB;AACD;;AACDO,QAAAA,iBAAiB,CAACV,KAAD,EAAQL,aAAR,CAAjB,CAAwCE,KAAxC,CAA8Cc,GAA9C,CAAkDR,IAAlD;AACAH,QAAAA,KAAK,CAACZ,cAAN,CAAqBwB,MAArB,CAA4BT,IAA5B;AACA,eAAOH,KAAP;AACD;;AACD,SAAM,aAAN;AAAoB;AAClB;AACA;AACA;AACA;AACA;AACA;AACAA,QAAAA,KAAK,CAACZ,cAAN,CAAqBuB,GAArB,CAAyBV,MAAM,CAACG,OAAP,CAAeD,IAAxC;AACA,eAAOH,KAAP;AACD;;AACD,SAAM,cAAN;AAAqB;AACnB,YAAIC,MAAM,CAACG,OAAP,CAAeS,OAAf,KAA4B,aAAhC,EAA8C;AAC5C,iBAAOb,KAAP;AACD;;AACD,aAAK,MAAMc,OAAX,IAAsBd,KAAK,CAACZ,cAA5B,EAA4C;AAC1C,eAAK,MAAM2B,SAAX,IAAwBf,KAAK,CAACb,iBAAN,CAAwB6B,MAAxB,EAAxB,EAA0D;AACxDD,YAAAA,SAAS,CAAClB,KAAV,CAAgBe,MAAhB,CAAuBE,OAAvB;AACD;;AACDd,UAAAA,KAAK,GAAGiB,qBAAqB,CAACjB,KAAD,EAAQc,OAAR,CAA7B;AACAd,UAAAA,KAAK,GAAGkB,2BAA2B,CAAClB,KAAD,EAAQc,OAAR,CAAnC;AACAd,UAAAA,KAAK,CAACd,cAAN,CAAqB0B,MAArB,CAA4BE,OAA5B;AACD;;AACDd,QAAAA,KAAK,CAACZ,cAAN,CAAqB+B,KAArB;AACA,eAAOnB,KAAP;AACD;;AACD,SAAM,iBAAN;AAAwB;AACtB;AACA;AACA;AACA,cAAM;AAAEL,UAAAA,aAAF;AAAiBC,UAAAA;AAAjB,YAA2BK,MAAM,CAACG,OAAxC;AACA,cAAMW,SAAS,GAAGL,iBAAiB,CAACV,KAAD,EAAQL,aAAR,CAAnC;;AACA,YAAIyB,OAAO,CAACL,SAAS,CAACjB,MAAX,EAAmBnB,qBAAnB,CAAX,EAAsD;AACpD,iBAAOqB,KAAP;AACD;;AACD,YAAIe,SAAS,CAACnB,KAAV,KAAoBA,KAAxB,EAA+B;AAC7B;AACA,eAAK,MAAMkB,OAAX,IAAsBC,SAAS,CAAClB,KAAhC,EAAuC;AACrC,kBAAMD,KAAK,GAAGI,KAAK,CAACd,cAAN,CAAqBmB,GAArB,CAAyBS,OAAzB,CAAd;;AACA,gBAAIlB,KAAJ,EAAW;AACTA,cAAAA,KAAK,CAACJ,KAAN,GAAcgB,OAAO,CAACZ,KAAK,CAACJ,KAAP,EAAchB,eAAd,CAArB;AACAwB,cAAAA,KAAK,GAAGS,eAAe,CAACT,KAAD,EAAQc,OAAR,CAAvB;AACD;AACF;;AACDC,UAAAA,SAAS,CAACnB,KAAV,GAAkBA,KAAlB;AACD;;AACD,eAAOI,KAAP;AACD;;AACD,SAAM,gCAAN;AACA,SAAM,8BAAN;AACA,SAAM,gCAAN;AAAuC;AACrC,cAAM;AAAEL,UAAAA;AAAF,YAAoBM,MAAM,CAACG,OAAjC;AACA,cAAMW,SAAS,GAAGL,iBAAiB,CAACV,KAAD,EAAQL,aAAR,CAAnC;AACA,cAAM0B,GAAG,GAAGpB,MAAM,CAACC,IAAP,KAAiB,gCAA7B;AACAa,QAAAA,SAAS,CAACjB,MAAV,GAAmBU,OAAO,CAACO,SAAS,CAACjB,MAAX,EAAmBnB,qBAAnB,EAA0C0C,GAA1C,CAA1B;AACA,eAAOrB,KAAP;AACD;;AACD,SAAM,sBAAN;AAA6B;AAC3B;AACA;AACA,cAAMJ,KAAK,GAAGW,aAAa,CAACP,KAAD,EAAQC,MAAM,CAACG,OAAP,CAAekB,EAAvB,CAA3B;AACA1B,QAAAA,KAAK,CAACJ,KAAN,GAAcgB,OAAO,CAACZ,KAAK,CAACJ,KAAP,EAAchB,eAAd,CAArB,CAJ2B,CAK3B;AACA;AACA;;AACAwB,QAAAA,KAAK,CAACZ,cAAN,CAAqBwB,MAArB,CAA4BX,MAAM,CAACG,OAAP,CAAekB,EAA3C;AACA,eAAOtB,KAAP;AACD;;AACD,SAAM,qBAAN;AAA4B;AAC1BA,QAAAA,KAAK,CAACZ,cAAN,CAAqBuB,GAArB,CAAyBV,MAAM,CAACG,OAAhC;AACA,eAAOJ,KAAP;AACD;;AACD,SAAM,6BAAN;AAAoC;AAClC,cAAM;AAAEG,UAAAA,IAAI,EAAEW,OAAR;AAAiBS,UAAAA,MAAjB;AAAyBC,UAAAA;AAAzB,YAAwCvB,MAAM,CAACG,OAArD;;AACA,YAAImB,MAAJ,EAAY;AACVvB,UAAAA,KAAK,GAAGyB,iBAAiB,CAACzB,KAAD,EAAQc,OAAR,EAAiBS,MAAjB,CAAzB;AACD;;AACD,YAAIC,UAAJ,EAAgB;AACdxB,UAAAA,KAAK,GAAG0B,uBAAuB,CAAC1B,KAAD,EAAQc,OAAR,EAAiBU,UAAjB,CAA/B;AACD;;AACD,eAAOxB,KAAP;AACD;;AACD,SAAM,aAAN;AAAoB;AAClB;AACA,cAAM;AAAEG,UAAAA;AAAF,YAAWF,MAAM,CAACG,OAAxB;AACAJ,QAAAA,KAAK,GAAGiB,qBAAqB,CAACjB,KAAD,EAAQG,IAAR,CAA7B;AACAH,QAAAA,KAAK,GAAGkB,2BAA2B,CAAClB,KAAD,EAAQG,IAAR,CAAnC;AACA,cAAMP,KAAK,GAAGI,KAAK,CAACd,cAAN,CAAqBmB,GAArB,CAAyBF,IAAzB,CAAd;;AACA,YAAIP,KAAJ,EAAW;AACTA,UAAAA,KAAK,CAACH,OAAN,GAAgBe,OAAO,CAACZ,KAAK,CAACH,OAAP,EAAgBb,qBAAhB,CAAvB;AACD;;AACD,eAAOoB,KAAP;AACD;;AACD,SAAM,aAAN;AACA,SAAM,aAAN;AAAoB;AAAA;;AAClB,cAAM2B,IAAI,GAAG1B,MAAM,CAACG,OAApB;;AACA,YAAI,CAACuB,IAAL,EAAW;AACT,iBAAO3B,KAAP;AACD;;AACD,cAAM4B,aAAa,wBAAG5B,KAAK,CAAClB,MAAN,CAAauB,GAAb,CAAiBsB,IAAI,CAACL,EAAtB,CAAH,iEAAgC,EAAnD;AACA,cAAMO,mBAAmB,4BACvB7B,KAAK,CAAChB,YAAN,CAAmBqB,GAAnB,CAAuBsB,IAAI,CAACG,QAAL,CAAc5B,IAArC,CADuB,yEACuB,EADhD;;AAGA,aAAK,MAAMY,OAAX,IAAsBc,aAAtB,EAAqC;AACnC,gBAAMhC,KAAK,GAAGI,KAAK,CAACd,cAAN,CAAqBmB,GAArB,CAAyBS,OAAzB,CAAd;;AACA,cAAIlB,KAAJ,EAAW;AACTA,YAAAA,KAAK,CAACJ,KAAN,GAAcgB,OAAO,CAACZ,KAAK,CAACJ,KAAP,EAAcf,eAAd,CAArB;AACAuB,YAAAA,KAAK,GAAGS,eAAe,CAACT,KAAD,EAAQc,OAAR,CAAvB;AACD;AACF;;AACD,aAAK,MAAMA,OAAX,IAAsBe,mBAAtB,EAA2C;AACzC,gBAAMjC,KAAK,GAAGI,KAAK,CAACd,cAAN,CAAqBmB,GAArB,CAAyBS,OAAzB,CAAd;;AACA,cAAIlB,KAAJ,EAAW;AACTA,YAAAA,KAAK,CAACJ,KAAN,GAAcgB,OAAO,CAACZ,KAAK,CAACJ,KAAP,EAAcf,eAAd,CAArB;AACAuB,YAAAA,KAAK,GAAGS,eAAe,CAACT,KAAD,EAAQc,OAAR,CAAvB;AACD;AACF;;AACD,eAAOd,KAAP;AACD;;AACD,SAAM,gBAAN;AAAuB;AACrB,cAAM;AAAEG,UAAAA;AAAF,YAAWF,MAAM,CAACG,OAAxB;AACA,cAAMR,KAAK,GAAGW,aAAa,CAACP,KAAD,EAAQG,IAAR,CAA3B;AACAP,QAAAA,KAAK,CAACJ,KAAN,GAAc,CAAd;AACAI,QAAAA,KAAK,CAACH,OAAN,GAAgB,CAAhB,CAJqB,CAIH;;AAClB,eAAOO,KAAP;AACD;;AACD,SAAM,oBAAN;AAA2B;AACzB,YAAIC,MAAM,CAACG,OAAP,KAAoB,oBAAxB,EAA6C;AAC3C;AACA,eAAK,MAAM,GAAGR,KAAH,CAAX,IAAwBI,KAAK,CAACd,cAA9B,EAA8C;AAC5CU,YAAAA,KAAK,CAACH,OAAN,GAAgB,CAAhB;AACD,WAJ0C,CAK3C;;;AACAO,UAAAA,KAAK,CAACV,kCAAN,GAA2C,EAA3C;AACD;;AACD,eAAOU,KAAP;AACD;;AACD,SAAM,sDAAN;AAA6D;AAC3DA,QAAAA,KAAK,CAACV,kCAAN,GAA2C,EAA3C;AACA,eAAOU,KAAP;AACD;;AACD,SAAM,0BAAN;AAAiC;AAC/B+B,QAAAA,wBAAwB,CAAC9B,MAAM,CAACG,OAAR,CAAxB;AAEAJ,QAAAA,KAAK,GAAGgC,2BAA2B,CAAChC,KAAD,EAAQC,MAAM,CAACG,OAAf,CAAnC;AACA,eAAOJ,KAAP;AACD;;AACD;AACE,aAAOA,KAAP;AAtKJ;AAwKD;;AAED,SAASQ,OAAT,CAAiByB,QAAjB,EAAmCC,IAAnC,EAAiDb,GAAG,GAAG,IAAvD,EAAqE;AACnE,MAAIY,QAAQ,GAAG,CAAf,EAAkB;AAChBA,IAAAA,QAAQ,GAAG,CAAX;AACD;;AACD,SAAOZ,GAAG,GAAGY,QAAQ,GAAGC,IAAd,GAAqBD,QAAQ,GAAG,CAACC,IAA3C;AACD;;AAEM,SAASd,OAAT,CAAiBa,QAAjB,EAAmCC,IAAnC,EAA0D;AAC/D,SAAOD,QAAQ,IAAI,CAAZ,IAAiB,CAACA,QAAQ,GAAGC,IAAZ,IAAoB,CAA5C;AACD;;AAED,SAAST,iBAAT,CACEzB,KADF,EAEEc,OAFF,EAGES,MAHF,EAI2B;AACzB;AACA;AACA;AACA,MAAIY,WAAW,GAAGnC,KAAK,CAAClB,MAAN,CAAauB,GAAb,CAAiBkB,MAAjB,CAAlB;;AACA,MAAI,CAACY,WAAL,EAAkB;AAChBA,IAAAA,WAAW,GAAG,IAAI9C,GAAJ,EAAd;AACAW,IAAAA,KAAK,CAAClB,MAAN,CAAauC,GAAb,CAAiBE,MAAjB,EAAyBY,WAAzB;AACD;;AACD,MAAIlD,UAAU,GAAGe,KAAK,CAACf,UAAN,CAAiBoB,GAAjB,CAAqBS,OAArB,CAAjB;;AACA,MAAI,CAAC7B,UAAL,EAAiB;AACfA,IAAAA,UAAU,GAAG,IAAII,GAAJ,EAAb;AACAW,IAAAA,KAAK,CAACf,UAAN,CAAiBoC,GAAjB,CAAqBP,OAArB,EAA8B7B,UAA9B;AACD;;AACDkD,EAAAA,WAAW,CAACxB,GAAZ,CAAgBG,OAAhB;AACA7B,EAAAA,UAAU,CAAC0B,GAAX,CAAeY,MAAf;AACA,SAAOvB,KAAP;AACD;;AAED,SAAS0B,uBAAT,CACE1B,KADF,EAEEc,OAFF,EAGEU,UAHF,EAI2B;AACzB;AACA;AACA,MAAIY,QAAQ,GAAGpC,KAAK,CAAChB,YAAN,CAAmBqB,GAAnB,CAAuBmB,UAAvB,CAAf;;AACA,MAAI,CAACY,QAAL,EAAe;AACbA,IAAAA,QAAQ,GAAG,IAAI/C,GAAJ,EAAX;AACAW,IAAAA,KAAK,CAAChB,YAAN,CAAmBqC,GAAnB,CAAuBG,UAAvB,EAAmCY,QAAnC;AACD;;AACDA,EAAAA,QAAQ,CAACzB,GAAT,CAAaG,OAAb;AACA,SAAOd,KAAP;AACD;;AAED,SAASiB,qBAAT,CACEjB,KADF,EAEEc,OAFF,EAG2B;AAAA;;AACzB,QAAMuB,YAAY,4BAAGrC,KAAK,CAACf,UAAN,CAAiBoB,GAAjB,CAAqBS,OAArB,CAAH,yEAAoC,IAAIzB,GAAJ,EAAtD;;AACA,OAAK,MAAMkC,MAAX,IAAqBc,YAArB,EAAmC;AACjC,UAAMF,WAAW,GAAGnC,KAAK,CAAClB,MAAN,CAAauB,GAAb,CAAiBkB,MAAjB,CAApB;;AACA,QAAIY,WAAJ,EAAiB;AACfA,MAAAA,WAAW,CAACvB,MAAZ,CAAmBE,OAAnB;AACD;AACF;;AACD,SAAOd,KAAP;AACD;;AAED,SAASkB,2BAAT,CACElB,KADF,EAEEc,OAFF,EAG2B;AACzB,OAAK,MAAM,GAAGsB,QAAH,CAAX,IAA2BpC,KAAK,CAAChB,YAAjC,EAA+C;AAC7CoD,IAAAA,QAAQ,CAACxB,MAAT,CAAgBE,OAAhB;AACD;;AACD,SAAOd,KAAP;AACD;;AAED,SAASO,aAAT,CACEP,KADF,EAEEc,OAFF,EAGe;AACb,MAAIlB,KAAK,GAAGI,KAAK,CAACd,cAAN,CAAqBmB,GAArB,CAAyBS,OAAzB,CAAZ;;AACA,MAAI,CAAClB,KAAL,EAAY;AACVA,IAAAA,KAAK,GAAGL,iBAAiB,EAAzB;AACAS,IAAAA,KAAK,CAACd,cAAN,CAAqBmC,GAArB,CAAyBP,OAAzB,EAAkClB,KAAlC;AACD;;AACD,SAAOA,KAAP;AACD;;AAED,SAASc,iBAAT,CACEV,KADF,EAEEL,aAFF,EAGmB;AACjB,MAAIoB,SAAS,GAAGf,KAAK,CAACb,iBAAN,CAAwBkB,GAAxB,CAA4BV,aAA5B,CAAhB;;AACA,MAAI,CAACoB,SAAL,EAAgB;AACdA,IAAAA,SAAS,GAAGrB,qBAAqB,EAAjC;AACAqB,IAAAA,SAAS,CAACpB,aAAV,GAA0BA,aAA1B;AACAK,IAAAA,KAAK,CAACb,iBAAN,CAAwBkC,GAAxB,CAA4B1B,aAA5B,EAA2CoB,SAA3C;AACD;;AACD,SAAOA,SAAP;AACD;;AAED,SAASN,eAAT,CACET,KADF,EAEEc,OAFF,EAG2B;AACzB,MAAIwB,OAAO,CAACC,GAAR,CAAYC,mCAAhB,EAAqD;AACnDxC,IAAAA,KAAK,CAACV,kCAAN,CAAyCmD,IAAzC,CAA8C3B,OAA9C;AACD;;AAED,SAAOd,KAAP;AACD;;AAOD,SAASgC,2BAAT,CACEhC,KADF,EAEE0C,gBAFF,EAG2B;AACzB,QAAMC,UAAU,GAAGD,gBAAgB,CAACE,eAApC,CADyB,CAGzB;;AACA,OAAK,MAAM9B,OAAX,IAAsB6B,UAAU,CAACzD,cAAX,CAA0B2D,IAA1B,EAAtB,EAAwD;AACtD7C,IAAAA,KAAK,GAAGiB,qBAAqB,CAACjB,KAAD,EAAQc,OAAR,CAA7B;AACAd,IAAAA,KAAK,GAAGkB,2BAA2B,CAAClB,KAAD,EAAQc,OAAR,CAAnC;AACD,GAPwB,CASzB;;;AACA,OAAK,MAAM,CAACS,MAAD,EAASuB,OAAT,CAAX,IAAgCH,UAAU,CAAC7D,MAA3C,EAAmD;AACjD,SAAK,MAAMgC,OAAX,IAAsBgC,OAAtB,EAA+B;AAC7B9C,MAAAA,KAAK,GAAGyB,iBAAiB,CAACzB,KAAD,EAAQc,OAAR,EAAiBS,MAAjB,CAAzB;AACD;AACF;;AACD,OAAK,MAAM,CAACwB,cAAD,EAAiBD,OAAjB,CAAX,IAAwCH,UAAU,CAAC3D,YAAnD,EAAiE;AAC/D,SAAK,MAAM8B,OAAX,IAAsBgC,OAAtB,EAA+B;AAC7B9C,MAAAA,KAAK,GAAG0B,uBAAuB,CAAC1B,KAAD,EAAQc,OAAR,EAAiBiC,cAAjB,CAA/B;AACD;AACF;;AACD,SAAO/C,KAAP;AACD;;AAED,SAAS+B,wBAAT,CAAkC;AAChCa,EAAAA,eADgC;AAEhCI,EAAAA;AAFgC,CAAlC,EAG4B;AAC1B,MAAIJ,eAAe,CAACxD,cAAhB,CAA+B6D,IAA/B,KAAwC,CAA5C,EAA+C;AAC7C,UAAM,IAAIC,KAAJ,CACH,oEAAmEF,QAAS,GADzE,CAAN;AAGD;;AACD,MAAIJ,eAAe,CAACzD,iBAAhB,CAAkC8D,IAAlC,KAA2C,CAA/C,EAAkD;AAChD,UAAM,IAAIC,KAAJ,CACH,2EAA0EF,QAAS,GADhF,CAAN;AAGD;;AACD,OAAK,MAAMpD,KAAX,IAAoBgD,eAAe,CAAC1D,cAAhB,CAA+B8B,MAA/B,EAApB,EAA6D;AAC3D,QAAIpB,KAAK,CAACJ,KAAV,EAAiB;AACf,YAAM,IAAI0D,KAAJ,CACH,+DAA8DF,QAAS,GADpE,CAAN;AAGD;;AACD,QAAIpD,KAAK,CAACH,OAAV,EAAmB;AACjB,YAAM,IAAIyD,KAAJ,CACH,iEAAgEF,QAAS,GADtE,CAAN;AAGD;AACF;AACF","sourcesContent":["import {\n  ActionsUnion,\n  IComponentState,\n  IGatsbyState,\n  IQueryState,\n} from \"../types\"\n\ntype QueryId = string // page query path or static query id\ntype ComponentPath = string\ntype NodeId = string\ntype ConnectionName = string\n\nexport const FLAG_DIRTY_NEW_PAGE = 0b0001\nexport const FLAG_DIRTY_TEXT = 0b0010\nexport const FLAG_DIRTY_DATA = 0b0100\nexport const FLAG_DIRTY_PAGE_CONTEXT = 0b1000\n\nexport const FLAG_ERROR_EXTRACTION = 0b0001\n\nexport const FLAG_RUNNING_INFLIGHT = 0b0001\n\nconst initialState = (): IGatsbyState[\"queries\"] => {\n  return {\n    byNode: new Map<NodeId, Set<QueryId>>(),\n    byConnection: new Map<ConnectionName, Set<QueryId>>(),\n    queryNodes: new Map<QueryId, Set<NodeId>>(),\n    trackedQueries: new Map<QueryId, IQueryState>(),\n    trackedComponents: new Map<ComponentPath, IComponentState>(),\n    deletedQueries: new Set<QueryId>(),\n    dirtyQueriesListToEmitViaWebsocket: [],\n  }\n}\n\nconst initialQueryState = (): IQueryState => {\n  return {\n    dirty: -1, // unknown, must be set right after init\n    running: 0,\n  }\n}\n\nconst initialComponentState = (): IComponentState => {\n  return {\n    componentPath: ``,\n    query: ``,\n    pages: new Set<QueryId>(),\n    errors: 0,\n    // TODO: staticQueries: new Set<QueryId>()\n  }\n}\n\n/**\n * Tracks query dirtiness. Dirty queries are queries that:\n *\n * - depend on nodes or node collections (via `actions.createPageDependency`) that have changed.\n * - have been recently extracted (or their query text has changed)\n * - belong to newly created pages (or pages with modified context)\n *\n * Dirty queries must be re-ran.\n */\nexport function queriesReducer(\n  state: IGatsbyState[\"queries\"] = initialState(),\n  action: ActionsUnion\n): IGatsbyState[\"queries\"] {\n  switch (action.type) {\n    case `DELETE_CACHE`:\n      return initialState()\n\n    case `CREATE_PAGE`: {\n      const { path, componentPath } = action.payload\n      let query = state.trackedQueries.get(path)\n      if (!query || action.contextModified) {\n        query = registerQuery(state, path)\n        query.dirty = setFlag(\n          query.dirty,\n          action.contextModified ? FLAG_DIRTY_PAGE_CONTEXT : FLAG_DIRTY_NEW_PAGE\n        )\n        state = trackDirtyQuery(state, path)\n      }\n      registerComponent(state, componentPath).pages.add(path)\n      state.deletedQueries.delete(path)\n      return state\n    }\n    case `DELETE_PAGE`: {\n      // Don't actually remove the page query from trackedQueries, just mark it as \"deleted\". Why?\n      //   We promote a technique of a consecutive deletePage/createPage calls in onCreatePage hook,\n      //   see https://www.gatsbyjs.com/docs/creating-and-modifying-pages/#pass-context-to-pages\n      //   If we remove a query and then re-add, it will be marked as dirty.\n      //   This is OK for cold cache but with warm cache we will re-run all of those queries (unnecessarily).\n      //   We will reconcile the state after createPages API call and actually delete those queries.\n      state.deletedQueries.add(action.payload.path)\n      return state\n    }\n    case `API_FINISHED`: {\n      if (action.payload.apiName !== `createPages`) {\n        return state\n      }\n      for (const queryId of state.deletedQueries) {\n        for (const component of state.trackedComponents.values()) {\n          component.pages.delete(queryId)\n        }\n        state = clearNodeDependencies(state, queryId)\n        state = clearConnectionDependencies(state, queryId)\n        state.trackedQueries.delete(queryId)\n      }\n      state.deletedQueries.clear()\n      return state\n    }\n    case `QUERY_EXTRACTED`: {\n      // Note: this action is called even in case of\n      // extraction error or missing query (with query === ``)\n      // TODO: use hash instead of a query text\n      const { componentPath, query } = action.payload\n      const component = registerComponent(state, componentPath)\n      if (hasFlag(component.errors, FLAG_ERROR_EXTRACTION)) {\n        return state\n      }\n      if (component.query !== query) {\n        // Invalidate all pages associated with a component when query text changes\n        for (const queryId of component.pages) {\n          const query = state.trackedQueries.get(queryId)\n          if (query) {\n            query.dirty = setFlag(query.dirty, FLAG_DIRTY_TEXT)\n            state = trackDirtyQuery(state, queryId)\n          }\n        }\n        component.query = query\n      }\n      return state\n    }\n    case `QUERY_EXTRACTION_GRAPHQL_ERROR`:\n    case `QUERY_EXTRACTION_BABEL_ERROR`:\n    case `QUERY_EXTRACTION_BABEL_SUCCESS`: {\n      const { componentPath } = action.payload\n      const component = registerComponent(state, componentPath)\n      const set = action.type !== `QUERY_EXTRACTION_BABEL_SUCCESS`\n      component.errors = setFlag(component.errors, FLAG_ERROR_EXTRACTION, set)\n      return state\n    }\n    case `REPLACE_STATIC_QUERY`: {\n      // Only called when static query text has changed, so no need to compare\n      // TODO: unify the behavior?\n      const query = registerQuery(state, action.payload.id)\n      query.dirty = setFlag(query.dirty, FLAG_DIRTY_TEXT)\n      // static queries are not on demand, so skipping tracking which\n      // queries were marked dirty recently\n      // state = trackDirtyQuery(state, action.payload.id)\n      state.deletedQueries.delete(action.payload.id)\n      return state\n    }\n    case `REMOVE_STATIC_QUERY`: {\n      state.deletedQueries.add(action.payload)\n      return state\n    }\n    case `CREATE_COMPONENT_DEPENDENCY`: {\n      const { path: queryId, nodeId, connection } = action.payload\n      if (nodeId) {\n        state = addNodeDependency(state, queryId, nodeId)\n      }\n      if (connection) {\n        state = addConnectionDependency(state, queryId, connection)\n      }\n      return state\n    }\n    case `QUERY_START`: {\n      // Reset data dependencies as they will be updated when running the query\n      const { path } = action.payload\n      state = clearNodeDependencies(state, path)\n      state = clearConnectionDependencies(state, path)\n      const query = state.trackedQueries.get(path)\n      if (query) {\n        query.running = setFlag(query.running, FLAG_RUNNING_INFLIGHT)\n      }\n      return state\n    }\n    case `CREATE_NODE`:\n    case `DELETE_NODE`: {\n      const node = action.payload\n      if (!node) {\n        return state\n      }\n      const queriesByNode = state.byNode.get(node.id) ?? []\n      const queriesByConnection =\n        state.byConnection.get(node.internal.type) ?? []\n\n      for (const queryId of queriesByNode) {\n        const query = state.trackedQueries.get(queryId)\n        if (query) {\n          query.dirty = setFlag(query.dirty, FLAG_DIRTY_DATA)\n          state = trackDirtyQuery(state, queryId)\n        }\n      }\n      for (const queryId of queriesByConnection) {\n        const query = state.trackedQueries.get(queryId)\n        if (query) {\n          query.dirty = setFlag(query.dirty, FLAG_DIRTY_DATA)\n          state = trackDirtyQuery(state, queryId)\n        }\n      }\n      return state\n    }\n    case `PAGE_QUERY_RUN`: {\n      const { path } = action.payload\n      const query = registerQuery(state, path)\n      query.dirty = 0\n      query.running = 0 // TODO: also\n      return state\n    }\n    case `SET_PROGRAM_STATUS`: {\n      if (action.payload === `BOOTSTRAP_FINISHED`) {\n        // Reset the running state (as it could've been persisted)\n        for (const [, query] of state.trackedQueries) {\n          query.running = 0\n        }\n        // Reset list of dirty queries (this is used only to notify runtime and it could've been persisted)\n        state.dirtyQueriesListToEmitViaWebsocket = []\n      }\n      return state\n    }\n    case `QUERY_CLEAR_DIRTY_QUERIES_LIST_TO_EMIT_VIA_WEBSOCKET`: {\n      state.dirtyQueriesListToEmitViaWebsocket = []\n      return state\n    }\n    case `MERGE_WORKER_QUERY_STATE`: {\n      assertCorrectWorkerState(action.payload)\n\n      state = mergeWorkerDataDependencies(state, action.payload)\n      return state\n    }\n    default:\n      return state\n  }\n}\n\nfunction setFlag(allFlags: number, flag: number, set = true): number {\n  if (allFlags < 0) {\n    allFlags = 0\n  }\n  return set ? allFlags | flag : allFlags & ~flag\n}\n\nexport function hasFlag(allFlags: number, flag: number): boolean {\n  return allFlags >= 0 && (allFlags & flag) > 0\n}\n\nfunction addNodeDependency(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId,\n  nodeId: NodeId\n): IGatsbyState[\"queries\"] {\n  // Perf: using two-side maps.\n  //   Without additional `queryNodes` map we would have to loop through\n  //   all existing nodes in `clearNodeDependencies` to delete node <-> query dependency\n  let nodeQueries = state.byNode.get(nodeId)\n  if (!nodeQueries) {\n    nodeQueries = new Set<QueryId>()\n    state.byNode.set(nodeId, nodeQueries)\n  }\n  let queryNodes = state.queryNodes.get(queryId)\n  if (!queryNodes) {\n    queryNodes = new Set<NodeId>()\n    state.queryNodes.set(queryId, queryNodes)\n  }\n  nodeQueries.add(queryId)\n  queryNodes.add(nodeId)\n  return state\n}\n\nfunction addConnectionDependency(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId,\n  connection: ConnectionName\n): IGatsbyState[\"queries\"] {\n  // Note: not using two-side maps for connections as associated overhead\n  //   for small number of elements is greater then benefits, so no perf. gains\n  let queryIds = state.byConnection.get(connection)\n  if (!queryIds) {\n    queryIds = new Set()\n    state.byConnection.set(connection, queryIds)\n  }\n  queryIds.add(queryId)\n  return state\n}\n\nfunction clearNodeDependencies(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId\n): IGatsbyState[\"queries\"] {\n  const queryNodeIds = state.queryNodes.get(queryId) ?? new Set()\n  for (const nodeId of queryNodeIds) {\n    const nodeQueries = state.byNode.get(nodeId)\n    if (nodeQueries) {\n      nodeQueries.delete(queryId)\n    }\n  }\n  return state\n}\n\nfunction clearConnectionDependencies(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId\n): IGatsbyState[\"queries\"] {\n  for (const [, queryIds] of state.byConnection) {\n    queryIds.delete(queryId)\n  }\n  return state\n}\n\nfunction registerQuery(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId\n): IQueryState {\n  let query = state.trackedQueries.get(queryId)\n  if (!query) {\n    query = initialQueryState()\n    state.trackedQueries.set(queryId, query)\n  }\n  return query\n}\n\nfunction registerComponent(\n  state: IGatsbyState[\"queries\"],\n  componentPath: string\n): IComponentState {\n  let component = state.trackedComponents.get(componentPath)\n  if (!component) {\n    component = initialComponentState()\n    component.componentPath = componentPath\n    state.trackedComponents.set(componentPath, component)\n  }\n  return component\n}\n\nfunction trackDirtyQuery(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId\n): IGatsbyState[\"queries\"] {\n  if (process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND) {\n    state.dirtyQueriesListToEmitViaWebsocket.push(queryId)\n  }\n\n  return state\n}\n\ninterface IWorkerStateChunk {\n  workerId: number\n  queryStateChunk: IGatsbyState[\"queries\"]\n}\n\nfunction mergeWorkerDataDependencies(\n  state: IGatsbyState[\"queries\"],\n  workerStateChunk: IWorkerStateChunk\n): IGatsbyState[\"queries\"] {\n  const queryState = workerStateChunk.queryStateChunk\n\n  // First clear data dependencies for all queries tracked by worker\n  for (const queryId of queryState.trackedQueries.keys()) {\n    state = clearNodeDependencies(state, queryId)\n    state = clearConnectionDependencies(state, queryId)\n  }\n\n  // Now re-add all data deps from worker\n  for (const [nodeId, queries] of queryState.byNode) {\n    for (const queryId of queries) {\n      state = addNodeDependency(state, queryId, nodeId)\n    }\n  }\n  for (const [connectionName, queries] of queryState.byConnection) {\n    for (const queryId of queries) {\n      state = addConnectionDependency(state, queryId, connectionName)\n    }\n  }\n  return state\n}\n\nfunction assertCorrectWorkerState({\n  queryStateChunk,\n  workerId,\n}: IWorkerStateChunk): void {\n  if (queryStateChunk.deletedQueries.size !== 0) {\n    throw new Error(\n      `Assertion failed: workerState.deletedQueries.size === 0 (worker #${workerId})`\n    )\n  }\n  if (queryStateChunk.trackedComponents.size !== 0) {\n    throw new Error(\n      `Assertion failed: queryStateChunk.trackedComponents.size === 0 (worker #${workerId})`\n    )\n  }\n  for (const query of queryStateChunk.trackedQueries.values()) {\n    if (query.dirty) {\n      throw new Error(\n        `Assertion failed: all worker queries are not dirty (worker #${workerId})`\n      )\n    }\n    if (query.running) {\n      throw new Error(\n        `Assertion failed: all worker queries are not running (worker #${workerId})`\n      )\n    }\n  }\n}\n"],"file":"queries.js"}